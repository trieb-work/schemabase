datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialActions"]
}

generator typegraphql {
  provider = "typegraphql-prisma"
}

// Visualize the schema
// https://github.com/notiz-dev/prisma-dbml-generator
// https://dbdiagram.io/d
generator dbml {
  provider = "prisma-dbml-generator"
}

model Order {
  // internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderId String @unique


  email String


  packages Package[]
}

enum PackageState {
  // Initial state when the package is created
  INIT

  // The carrier has received the shipment info and is about to pick up the package.
  INFORMATION_RECEIVED

  // The shipment has been accepted and is in transit now.
  IN_TRANSIT

  // The carrier is on its way to deliver the shipment.
  OUT_FOR_DELIVERY

  // The carrier attemptet to deliver the shipment but failed. It ususlly leavesa notice and will try to deliver again.
  FAILED_ATTEMPT

  // The shipment has been delivered successfully.
  DELIVERED

  // The package has arrived at the nearest pickup point and is available for pickup.
  AVAILABLE_FOR_PICKUP

  // Held at customs, undelivered, returned to sender, or any other shipping exceptions.
  EXCEPTION

  // The shipment has expired as the carrier didn't return the tracking info for the lat 30 days.
  EXPIRED

  // The shipment is pending as the carrier didn't return the tracking info.
  PENDING
}

enum Carrier {
  DPD
}

model Package {
  // internal id
  id                 String         @id
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  carrier            Carrier
  state             PackageState
  // tracking id from the carrier
  trackingId         String         @unique
  // A link to the carriers tracking page
  carrierTrackingUrl String         @unique
  order              Order          @relation(fields: [orderId], references: [orderId], onDelete: Cascade)
  orderId            String
  events             PackageEvent[]
}

model PackageEvent {
  id String @id


  // When the event happened
  time DateTime

  state PackageState

  // What happened
  // eg: "The shipment has cleared customs"
  message String

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  // `NÃ¼rnberg, Deutschland` for example
  location  String
  sentEmail TransactionalEmail?
}

model TransactionalEmail {
  id    String   @id
  time  DateTime
  email String

  // The related package event that caused this email to be sent
  packageEvent   PackageEvent @relation(fields: [packageEventId], references: [id])
  packageEventId String       @unique
}

model TrackingEmailApp {
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  SendgridTemplate SendgridTemplate[]

  sender              String
  replyTo             String
  integration TrackingIntegration[]
}

model SendgridTemplate {
  // internal id
  id                 String           @id
  // A human readable name provided by the user
  // To use internationalized emails you should prefix the name with the language code
  // for example: `en:delivered`
  // Together with the trackingEmailAppId this can be used as primary key
  name               String
  // Localized subject for the email
  subject            String
  // The template id in sendgrid
  templateId         String
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id], onDelete: Cascade)
  trackingEmailAppId String

  @@unique([trackingEmailAppId, name])
}

model DpdApp {
  id String @id

  name String?

  tenant              Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId            String                @unique
  integration TrackingIntegration?

  webhooks   IncomingDPDWebhook[]

}

model ProductDataFeedApp {
  // internal id
  id                         String                           @id
  // Graphql endpoint of a saleor app
  productDetailStorefrontURL String
  saleorApp                  SaleorApp                        @relation(fields: [saleorAppId], references: [id])
  saleorAppId                String
  tenant                     Tenant                           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId                   String                           @unique
  webhooks                   IncomingProductDataFeedWebhook[]
  integration                ProductDataFeedIntegration?
}

model LogisticsApp {
  id String @id

  // The custom view ID use to get all current orders
  currentOrdersCustomViewId String

  // Regular orders in the next fice days custom view
  nextFiveDaysOrdersCustomViewId String

  // The custom view ID to get all current bulk orders
  currentBulkOrdersCustomViewId String

  // custom view ID to get all bulk orders for the next days
  nextFiveDaysBulkOrdersCustomViewId String


  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingLogisticsWebhook[]
  integration LogisticsIntegration?
}

model ZohoApp {
  id String @id

  orgId                   String
  clientId                String
  clientSecret            String
  tenant                  Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId                String                    @unique
  strapiToZohoIntegration StrapiToZohoIntegration[]
  logisticsIntegration    LogisticsIntegration[]
}

// Saleor Apps are separate applications that use GraphQL to talk to a Saleor
// server and receive webhooks with event notifications from Saleor.
// Every tenant can have multiple saleor apps which correspond to different
// saleor instances.
model SaleorApp {

  id String @id

  // The domain of a running saleor instance.
  // You can prefix with http:// or https:// if you want.
  // If no protocol is specified, https:// is assumed.
  domain String

  name String

  channelSlug String?

  installedSaleorApp InstalledSaleorApp?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productDataFeedIntegration ProductDataFeedIntegration[]

  productDataFeedApp ProductDataFeedApp[]
  @@unique([domain, channelSlug])
}

model InstalledSaleorApp {
  // The saleor application id
  // This is the id for the app on saleor's side and can be used in queries and
  // mutations to identify the app.
  id String @id

  // Every SaleorApp can have multiple webhooks configured.
  // This is not really necessary because a webhook can fire on multiple events
  // but let's be on the safe side.
  webhooks IncomingSaleorWebhook[]

  // Unlike regular users, Saleor Apps use a bearer token. The token is
  // assigned at App installation time and needs to be stored in a secure manner.
  // The authorization header for Apps has the following format:
  // Authorization: Bearer <app-token>
  token String


  saleorApp   SaleorApp @relation(fields: [saleorAppId], references: [id], onDelete: Cascade)
  saleorAppId String    @unique
}

// One tenant per company
// Every tenant can have multiple connections with every integration.
model Tenant {
  id String @id

  // Human readable identifier
  name String

  subscriptions Subscription[]

  // App configurations
  saleorApps                 SaleorApp[]
  zohoApps                   ZohoApp[]
  productdatafeedApps        ProductDataFeedApp[]
  strapiApps                 StrapiApp[]
  productDataFeedIntegration ProductDataFeedIntegration[]
  strapiToZohoIntegration    StrapiToZohoIntegration[]
  logisticsIntegration       LogisticsIntegration[]
  logisticsApp               LogisticsApp[]
  trackingEmailApp           TrackingEmailApp[]
  dpdApp                     DpdApp[]
  trackingIntegration        TrackingIntegration[]
}

// A subscription indicates a tenant has payed for one integration.
model Subscription {
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  payedUntil DateTime?

  productDataFeedIntegration ProductDataFeedIntegration?
  strapiToZohoIntegration    StrapiToZohoIntegration?
  logisticsIntegration       LogisticsIntegration?
  trackingIntegration        TrackingIntegration?
}

// ----------------------------------------------------------------------------
// Integrations
//
// Every integration is a connection between application configurations and a tenant
// ----------------------------------------------------------------------------

model TrackingIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  dpdApp   DpdApp @relation(fields: [dpdAppId], references: [id])
  dpdAppId String @unique

  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id])
  trackingEmailAppId String

}

model ProductDataFeedIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productDataFeedApp   ProductDataFeedApp @relation(fields: [productDataFeedAppId], references: [id])
  productDataFeedAppId String             @unique
  saleorApp            SaleorApp          @relation(fields: [saleorAppId], references: [id])
  saleorAppId          String
}

model LogisticsIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  logisticsApp   LogisticsApp @relation(fields: [logisticsAppId], references: [id])
  logisticsAppId String       @unique
}

model StrapiToZohoIntegration {
  id         String    @id
  payedUntil DateTime?
  enabled    Boolean   @default(true)

  // The Content type of BulkOrders
  strapiContentType String @default("bulkorder")



  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId    String
  strapiApp   StrapiApp @relation(fields: [strapiAppId], references: [id])
  strapiAppId String    @unique
  zohoApp     ZohoApp   @relation(fields: [zohoAppId], references: [id])
  zohoAppId   String

}

// Every tenant can have multiple strapi instances
model StrapiApp {
  id String @id

  name     String
  webhooks IncomingStrapiWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  integration StrapiToZohoIntegration?
}

// ----------------------------------------------------------------------------
// Every Config/App can have multiple webhooks attached
// ----------------------------------------------------------------------------



model IncomingDPDWebhook {
  id   String  @id
  // Human readable name
  name String?


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  dpdApp   DpdApp @relation(fields: [dpdAppId], references: [id], onDelete: Cascade)
  dpdAppId String
}

model IncomingSaleorWebhook {
  id   String  @id
  // Human readable name
  name String?


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  secret   SecretKey @relation(fields: [secretId], references: [id])
  secretId String    @unique

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String
}

model IncomingStrapiWebhook {
  id   String  @id
  // Human readable name
  name String?


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  secret   SecretKey @relation(fields: [secretId], references: [id])
  secretId String    @unique

  strapiApp   StrapiApp @relation(fields: [strapiAppId], references: [id], onDelete: Cascade)
  strapiAppId String
}

model IncomingProductDataFeedWebhook {
  id   String  @id
  // Human readable name
  name String?


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productDataFeedApp   ProductDataFeedApp @relation(fields: [productDataFeedAppId], references: [id], onDelete: Cascade)
  productDataFeedAppId String
}

model IncomingLogisticsWebhook {
  id   String  @id
  // Human readable name
  name String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  logisticsApp   LogisticsApp @relation(fields: [logisticsAppId], references: [id], onDelete: Cascade)
  logisticsAppId String
}

// Until prisma allows for inheritance we are stuck createing different webhook modules
// with duplicate code

// model IncomingWebhook {
//   id String @id

//   // Human readable name
//   name String?

//   createdAt DateTime  @default(now())
//   updatedAt DateTime  @updatedAt
//

//   secret   SecretKey @relation(fields: [secretId], references: [id])
//   secretId String

//   // Webhook connections
//   productDataFeed   ProductDataFeedApp? @relation(fields: [productDataFeedId], references: [id], onDelete: Cascade)
//   productDataFeedId String?
//   saleorApp         SaleorApp?          @relation(fields: [saleorAppId], references: [id], onDelete: Cascade)
//   saleorAppId       String?
//   strapi            StrapiApp?          @relation(fields: [strapiAppId], references: [id], onDelete: Cascade)
//   strapiAppId       String?
// }
model SecretKey {
  id String @id @default(uuid())

  // Human readable name
  name      String?
  secret    String
  createdAt DateTime @default(now())


  // Connections ..
  // Required by prisma
  incomingSaleorWebhook IncomingSaleorWebhook?
  IncomingStrapiWebhook IncomingStrapiWebhook?
}
