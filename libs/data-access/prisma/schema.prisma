datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialActions"]
}

generator typegraphql {
  provider = "typegraphql-prisma"
}

// Visualize the schema
// https://github.com/notiz-dev/prisma-dbml-generator
// https://dbdiagram.io/d
generator dbml {
  provider = "prisma-dbml-generator"
}

model ProductDataFeed {
  id       String @id @default(uuid())
  // The public id used for lookups from incoming webhooks.
  publicId String @unique

  // Indicates if the integration is currently enabled.
  // The user might chose to disable it.
  enabled Boolean? @default(false)

  // Graphql endpoint of a saleor app
  productDetailStorefrontURL String?
  tenant                     Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId                   String            @unique
  ProductDataFeedWebhook     IncomingWebhook[]
}

model ZohoConfig {
  id String @id @default(uuid())

  // Indicates if the integration is currently enabled.
  // The user might chose to disable it.
  enabled             Boolean @default(false)
  // The public id used for lookups from incoming webhooks.
  publicId            String
  orgId               String
  clientId            String
  clientSecret        String
  payPalAccountId     String?
  creditCardAccountId String?
  webhookToken        String
  webhookID           String?
  customFunctionID    String?
  tenant              Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId            String  @unique
}

// Saleor Apps are separate applications that use GraphQL to talk to a Saleor
// server and receive webhooks with event notifications from Saleor.
// Every channel must have its own app
model SaleorApp {
  id          String @id
  channelSlug String
  domain      String @unique

  name String
  // The saleor application id
  // appId        String

  // Unlike regular users, Saleor Apps use a bearer token. The token is
  // assigned at App installation time and needs to be stored in a secure manner.
  // The authorization header for Apps has the following format:
  // Authorization: Bearer <app-token>
  appToken String

  // Every SaleorApp can have multiple webhooks configured.
  // This is not really necessary because a webhook can fire on multiple events
  // but let's be on the safe side.
  webhooks IncomingWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([domain, channelSlug])
}

// One tenant per company
// Every tenant can have multiple connections with every integration.
model Tenant {
  id String @id

  // Human readable identifier
  name String
  // customer data etc
  // metadata Metadata

  // Indicates if the integration is currently enabled.
  // The user might chose to disable it.
  enabled         Boolean           @default(false)
  // baseUrl         String
  saleorApps      SaleorApp[]
  zoho            ZohoConfig[]
  productdatafeed ProductDataFeed[]
  strapi          Strapi[]
}

model Strapi {
  id String @id

  name     String
  webhooks IncomingWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

}

// ----------------------------------------------------------------------------
// Every Config/App can have multiple webhooks attached
// ----------------------------------------------------------------------------

model IncomingWebhook {
  id String @id

  // Human readable name
  name String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  lastUsed  DateTime?

  secret   SecretKey @relation(fields: [secretId], references: [id])
  secretId String


  // Various configs that process incoming webhooks:

  strapi   Strapi? @relation(fields: [strapiId], references: [id], onDelete: Cascade)
  strapiId String?

  saleor    SaleorApp? @relation(fields: [saleorApp], references: [id], onDelete: Cascade)
  saleorApp String?

  productDataFeed   ProductDataFeed? @relation(fields: [productDataFeedId], references: [id], onDelete: Cascade)
  productDataFeedId String?
}

model SecretKey {
  id   String  @id @default(uuid())
  // Human readable name
  name String?

  // sha256 of the actual key
  hash String

  createdAt DateTime  @default(now())
  lastUsed  DateTime?

  // Connections ..
  // Required by prisma
  IncomingWebhook IncomingWebhook?
}
