datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  // shadowDatabaseUrl    = env("SHADOW_DATABASE_URL")
  relationMode = "prisma"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

generator client {
  provider        = "prisma-client-js"
}


/// ECI Internal model to store cookies / additional headers, that
/// might be needed for some apps
model Cookies {
  id  String @id @default(cuid())

  key     String
  value   String

  installedSaleorApp    InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id])
  installedSaleorAppId  String?

  @@index([installedSaleorAppId])

}

// ------------------------------------------------------------------------------------------------
//
//  SALEOR SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------

// Saleor specific model for orders.
model SaleorOrder {
  /// Saleor Internal Id
  id String

  createdAt DateTime

  order   Order  @relation(fields: [orderId, orderNumber], references: [id, orderNumber], onDelete: Cascade)
  orderId String

  // The Human-Readable order number. Gets
  // prefixed with something like "STORE-" when moved to Zoho
  orderNumber String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  saleorPayment SaleorPayment[]

  @@unique([id, installedSaleorAppId])
  @@unique([orderId, installedSaleorAppId])
  @@index([orderId])
  @@index([installedSaleorAppId])
  @@index([orderNumber])
  @@index([id])
  @@index([orderId, orderNumber])
}

model SaleorPackage {
  /// Saleor Internal Id
  id String

  createdAt DateTime

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([packageId])
  @@index([installedSaleorAppId])
  @@index([id])
}

// model for saleor fulfillment line items
model SaleorFulfillmentLine {
  /// Saleor Internal Id
  id String

  packagelineItem   PackageLineItem @relation(fields: [packageLineItemId], references: [id], onDelete: Cascade)
  packageLineItemId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([packageLineItemId])
  @@index([installedSaleorAppId])
}

model SaleorOrderLineItem {
  /// Saleor Internal Id
  id String

  orderLineItem   OrderLineItem @relation(fields: [orderLineItemId], references: [id], onDelete: Cascade)
  orderLineItemId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([orderLineItemId])
  @@index([installedSaleorAppId])
}

// Saleor specific model for payments.
model SaleorPayment {
  /// Saleor Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  saleorOrder   SaleorOrder? @relation(fields: [saleorOrderId, installedSaleorAppId], references: [id, installedSaleorAppId])
  saleorOrderId String?

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([paymentId])
  @@index([installedSaleorAppId])
  @@index([saleorOrderId])
  @@index([saleorOrderId, installedSaleorAppId])
}

// Saleor specific model for product variant.
model SaleorProductVariant {
  /// Saleor internal product variant id
  id String

  /// Saleor internal product Id
  productId String

  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([productVariantId])
  @@index([installedSaleorAppId])
}

// Saleor specific model for warehouse.
model SaleorWarehouse {
  /// Saleor Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([installedSaleorAppId])
  @@index([warehouseId])
}

model SaleorPaymentGateway {
  /// Saleor Internal Id
  id String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  paymentMethods PaymentMethod[]

  @@unique([id, installedSaleorAppId])
  @@index([installedSaleorAppId])
}

// ------------------------------------------------------------------------------------------------
//
//  Zoho SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------
// Zoho specific model for item metadata. For simplicity, we don't use a seperate product and product variant table.
model ZohoItem {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([productVariantId])
}

model ZohoPackage {
  /// Zoho Internal Id
  id String

  // Zoho has the entities shipment and package.
  // we track both in this entity
  shipmentId String?

  createdAt DateTime
  updatedAt DateTime

  shipmentStatus String?

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([packageId])
  @@index([id])
  @@index([shipmentStatus])
}

model ZohoContact {
  // Zoho Internal Contact Id
  id String

  // We set these optional, so that we
  // can easily upsert ZohoContactPerson
  createdAt DateTime?
  updatedAt DateTime?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  zohoContactPerson ZohoContactPerson[]
  zohoSalesOrder    ZohoSalesOrder[]
  zohoAddress       ZohoAddress[]
  // zohoInvoice       ZohoInvoice[]
  // zohoPayment       ZohoPayment[]

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
}

// Zoho knows Contacts and ContactPersons.
model ZohoContactPerson {
  /// Zoho Internal ContactPerson Id
  id String

  /// Contacts/Contactpersons can be disabled to filter out merged contacts
  active Boolean @default(true)

  /// Just one Zoho Contact Person can be primary
  isPrimary Boolean @default(false)

  zohoContact   ZohoContact @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId String

  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId String
  // For easy look-up directly in the ZohoContact model. Is set automatically from related contact 
  email     String?

  // zohoPayments ZohoPayment[]

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  // zohoInvoices    ZohoInvoice[]
  zohoSalesOrders ZohoSalesOrder[]

  @@unique([id, zohoAppId])
  @@index([contactId])
  @@index([zohoContactId])
  @@index([zohoContactId, zohoAppId])
  @@index([zohoAppId])
  @@index([active])
  @@index([isPrimary])
  @@index([id])
}

model ZohoAddress {
  /// Zoho internal Address id
  id String

  address   Address @relation(fields: [addressId], references: [id], onDelete: Cascade)
  addressId String

  /// Zoho Addresses are valid only per zoho contact. Sometimes, we have different
  /// customers with the same address. To not get any issues, we need to store the customer id
  zohoContact    ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId  String?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([id])
  @@index([zohoAppId])
  @@index([addressId])
  @@index([zohoContactId, zohoAppId])
}

enum ZohoSalesOrderStatus {
  draft
  confirmed
  fulfilled
  shipped
}

// Zoho specific model.
model ZohoSalesOrder {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  zohoContact   ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId String?

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  /// The ECI internal order ID 
  orderId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  zohoContactPerson          ZohoContactPerson? @relation(fields: [zohoContactPersonId, zohoContactPersonZohoAppId], references: [id, zohoAppId])
  zohoContactPersonId        String?
  zohoContactPersonZohoAppId String?

  @@unique([id, zohoAppId])
  @@index([orderId])
  @@index([zohoAppId])
  @@index([id])
  @@index([zohoContactPersonId, zohoContactPersonZohoAppId])
  @@index([zohoContactId, zohoAppId])
}

// Zoho specific model.
model ZohoInvoice {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  // The Zoho Internal Invoice number
  // as complete string: INV-395956
  number String

  // zohoContact   ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  // zohoContactId String?

  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  // zohoContactPerson          ZohoContactPerson? @relation(fields: [zohoContactPersonId, zohoContactPersonZohoAppId], references: [id, zohoAppId])
  // zohoContactPersonId        String?
  // zohoContactPersonZohoAppId String?

  @@unique([id, zohoAppId])
  @@unique([number, zohoAppId])
  @@index([zohoAppId])
  @@index([invoiceId])
}

/// Zoho specific model.
model ZohoPayment {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?  @unique

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([paymentId])
  @@index([zohoAppId])
}

model ZohoBankAccount {
  /// Zoho Internal Bankacount Id

  id String

  name     String
  currency Currency
  active   Boolean  @default(true)

  paymentMethod   PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId String?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([paymentMethodId])
}

model ZohoWarehouse {
  /// Zoho Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([warehouseId])
}

model ZohoTax {
  /// internal ID of tax in Zoho
  id String

  tax   Tax    @relation(fields: [taxId], references: [id], onDelete: Cascade)
  /// ID of eci internal Tax Object
  taxId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([id])
  @@index([zohoAppId])
  @@index([taxId])
}

model ZohoOrderLineItem {
  /// Zoho Internal Id
  id String

  orderLineItem   OrderLineItem @relation(fields: [orderLineItemId], references: [id], onDelete: Cascade)
  orderLineItemId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([orderLineItemId])
  @@index([zohoAppId])
}

model ZohoPackageLineItem {
  /// Zoho Internal Id
  id String

  packagelineItem   PackageLineItem @relation(fields: [packagelineItemId], references: [id], onDelete: Cascade)
  packagelineItemId String

  zohoApp         ZohoApp        @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId       String
  orderLineItem   OrderLineItem? @relation(fields: [orderLineItemId], references: [id])
  orderLineItemId String?

  @@unique([id, zohoAppId])
  @@index([packagelineItemId])
  @@index([zohoAppId])
  @@index([orderLineItemId])
}

// ------------------------------------------------------------------------------------------------
//
//  ECI INTERNAL ENTITY MODELS
//
// ------------------------------------------------------------------------------------------------

// The ECI internal invoice model
model Invoice {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Un-Prefixed Invoice Number (e.g. 30994)
  // Invoice-Numbers have to be unique per Tenant!
  // We use them as unique identifier between systems
  invoiceNumber     String
  invoiceTotalGross Float
  invoiceCurrency   Currency

  payments Payment[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  orders      Order[]
  zohoInvoice ZohoInvoice[]

  /// The person who has created this Invoice (In other systems this can also be a Useraccount)
  mainContact   Contact? @relation(references: [id], fields: [mainContactId])
  mainContactId String?

  @@unique([invoiceNumber, tenantId])
  @@index([invoiceNumber])
  @@index([tenantId])
  @@index([mainContactId])
}

// Internal model to save taxes information
model Tax {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  // Lowercase, trim, whitespace remove, special characters remove etc.
  normalizedName String
  percentage     Float

  /// An array of orders where this tax is used as the tax for the shipping method
  shippingTaxInOrders Order[]
  /// An array of lineitems where this tax is used as the tax for the line item
  taxInLineItems      OrderLineItem[]

  productVariants      ProductVariant[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoTaxes ZohoTax[]

  @@unique([normalizedName, tenantId])
  @@unique([percentage, tenantId])
  @@index([percentage])
  @@index([tenantId])
}

/// The ECI internal payments model
model Payment {
  /// eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Unique identifier for a customer payment. We use the payment gateway id as reference.
  referenceNumber String

  amount Float

  /// Costs for this transaction, for example bank charges, gateway charges, paypal charges
  transactionFee Float @default(0)

  order   Order?  @relation(fields: [orderId], references: [id])
  orderId String?

  /// The person who has created this Payment (In other systems this can also be a Useraccount)
  mainContact   Contact? @relation(references: [id], fields: [mainContactId])
  mainContactId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId String

  invoices Invoice[]

  zohoPayment           ZohoPayment[]
  saleorPayment         SaleorPayment[]
  braintreeTransactions BraintreeTransaction[]

  @@unique([orderId, tenantId])
  @@unique([referenceNumber, tenantId])
  @@index([orderId])
  @@index([tenantId])
  @@index([paymentMethodId])
  @@index([mainContactId])
}

/// categorize payments by payment method type
enum PaymentMethodType {
  paypal
  card
  /// banktransfer = Vorkasse
  banktransfer
}

/// categorize payments by gateway type
enum GatewayType {
  braintree
  paypal
  stripe
  /// banktransfer = Vorkasse
  banktransfer
}

/// Internal representation of payment methods. We try to normalize different payment types to more generic ones.
model PaymentMethod {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  gatewayType GatewayType
  methodType  PaymentMethodType
  currency    Currency

  saleorPaymentGateway                     SaleorPaymentGateway? @relation(fields: [saleorPaymentGatewayId, saleorPaymentGatewayInstalledSaleorAppId], references: [id, installedSaleorAppId], onDelete: Cascade)
  saleorPaymentGatewayId                   String?
  saleorPaymentGatewayInstalledSaleorAppId String?

  /// One internal payment method can have multiple Zoho Bank Accounts. Internally, we know for example just "banktransfer" but in Zoho we might have multiple
  /// bank Accounts
  zohoBankAccounts ZohoBankAccount[]

  payments Payment[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([gatewayType, methodType, currency, tenantId])
  @@index([tenantId])
  @@index([saleorPaymentGatewayId, saleorPaymentGatewayInstalledSaleorAppId])
}

model Company {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  // Lowercase, trim, whitespace remove, special characters remove etc.
  normalizedName String

  contacts Contact[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

/// The ECI internal contact model. One contact has one E-Mail address only. E-Mail addresses are unique per tenant. In some systems the Contact is equal to Users or Accounts
model Contact {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  email String

  firstName String?
  lastName  String?

  orders Order[]
  invoices Invoice[]
  payments Payment[]

  /// A Contact can be related to one company
  company   Company? @relation(fields: [companyId], references: [id])
  companyId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoContactPersons ZohoContactPerson[]
  addresses          Address[]

  /// If we have the users permission to send tracking emails
  trackingEmailsConsent   Boolean @default(true)
  /// If we have the users consent to send marketing emails
  marketingEmailsConstent Boolean @default(false)

  @@unique([email, tenantId])
  @@index([companyId])
  @@index([tenantId])
  @@index([email])
}

// The ECI internal Warehouse model.
model Warehouse {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName String

  tenant          Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId        String
  zohoWarehouse   ZohoWarehouse[]
  saleorWarehouse SaleorWarehouse[]
  xentralProxyApp XentralProxyApp[]
  installedSaleorApp InstalledSaleorApp[]

  packageLineItems     PackageLineItem[]
  stockEntries         StockEntries[]
  isDefaultWarehouseOf ProductVariant[]

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

enum Currency {
  EUR
  USD
}

// The ECI internal LineItem model
model OrderLineItem {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique string to identify this LineItem
  // between different systems. For orders:
  // ${orderNumber}${sku}${quantity}
  // For invoices: ${invoiceNumber}${sku}${quantity}
  // For packages: ${packageNumber}${sku}${quantity} 
  uniqueString String

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String

  quantity Float
  sku      String
  tax      Tax    @relation(fields: [taxId], references: [id], onDelete: Cascade)
  taxId    String

  /// The total net price (price excluding taxes) of all line item. Optional, as we might have just one of the two values on hand
  totalPriceNet   Float?
  /// The total gross price (price including taxes) of all line item. Optional, as we might have just one of the two values on hand
  totalPriceGross Float?

  /// The unit net price (price excluding taxes) of one line item. Optional, as we might have just one of the two values on hand
  undiscountedUnitPriceNet   Float?
  /// The unit gross price (price including taxes) of one line item. Optional, as we might have just one of the two values on hand
  undiscountedUnitPriceGross Float?

  /// The disount amount, that is applied to the net price (discount excluding taxes).
  discountValueNet Float @default(0)
  /// The disount amount, that is applied to the gross price (discount including taxes).
  //discountValueGross Float @default(0)

  productVariant   ProductVariant @relation(fields: [productVariantId, sku], references: [id, sku])
  productVariantId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoPackageLineItems ZohoPackageLineItem[]
  saleorOrderLineItems SaleorOrderLineItem[]
  zohoOrderLineItems   ZohoOrderLineItem[]

  @@unique([uniqueString, tenantId])
  @@index([orderId])
  @@index([productVariantId])
  @@index([uniqueString])
  @@index([tenantId])
  @@index([sku])
  @@index([productVariantId, sku])
  @@index([taxId])
}

model PackageLineItem {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique string to identify this LineItem
  // between different systems.
  // For packages: ${packageNumber}${sku}${quantity} 
  uniqueString String

  // order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  // orderId String

  // Warehouse, this line item corresponds to.
  // Warehouse can be undefined, as we have non-inventory products as well.
  warehouse   Warehouse? @relation(fields: [warehouseId], references: [id])
  warehouseId String?

  package   Package? @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String?

  quantity       Float
  sku            String
  // TODO changed fields from productVariantId, sku to tenantId, sku because these fields already exist and will it more easy during creation
  productVariant ProductVariant @relation(fields: [tenantId, sku], references: [tenantId, sku])

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoPackageLineItems    ZohoPackageLineItem[]
  saleorFulfillmentsLines SaleorFulfillmentLine[]

  @@unique([uniqueString, tenantId])
  // @@index([orderId])
  @@index([packageId])
  @@index([warehouseId])
  @@index([uniqueString])
  @@index([tenantId])
  @@index([sku])
  @@index([tenantId, sku])
}

enum OrderStatus {
  draft
  unconfirmed
  confirmed
  // The order is fulfilled + paid -> finished
  closed
  canceled
}

enum OrderPaymentStatus {
  unpaid
  fullyPaid
  partiallyPaid
  fullyRefunded
  partiallyRefunded
}

enum OrderShipmentStatus {
  pending
  partiallyShipped
  shipped
  delivered
}

enum OrderInvoiceStatus {
  notInvoiced
  invoiced
}

// The ECI internal Order model.

model Order {
  // eci internal id
  id        String   @id
  // Created and updated at the ECI DB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // the order date
  date DateTime

  /// The Date, that we expect this order to be shipped.
  expectedShippingDate DateTime?

  /// The expected shipment carrier for this order
  carrier   Carrier?

  /// Add messages, that will be printed on order and shipping documents for the customer
  customerNote  String?

  orderStatus    OrderStatus         @default(draft)
  paymentStatus  OrderPaymentStatus  @default(unpaid)
  shipmentStatus OrderShipmentStatus @default(pending)
  invoiceStatus  OrderInvoiceStatus  @default(notInvoiced)

  /// In PuF: if the Order is not readyToFullfill it woll not get transfered to logistics partner (kramer); default is false
  readyToFullfill Boolean @default(false)

  /// Order-Numbers have to be unique per Tenant!
  /// We use them as unique identifier between systems
  orderNumber     String
  /// if source system has a second ID which is benefitial to the user, we can provide it here
  referenceNumber String?

  orderLineItems OrderLineItem[]

  shippingPriceNet   Float?
  shippingPriceGross Float?
  shippingPriceTax   Tax?    @relation(fields: [shippingPriceTaxId], references: [id], onDelete: Cascade)
  shippingPriceTaxId String?

  /// The applied discount code
  discountCode String?

  /// The disount amount, that is applied
  /// to the net, undiscounted subtotal price.
  /// Discounts never get applied on shipping costs
  discountValueNet Float @default(0)

  /// The disount percentage, that is applied
  /// to the net, undiscounted subtotal price.
  /// Discounts never get applied on shipping costs
  discountValueNetPercentage Float @default(0)

  // The final, total price
  totalPriceNet   Float?
  totalPriceGross Float

  /// The person who has created this Order (In other systems this can also be a Useraccount)
  mainContact   Contact @relation(references: [id], fields: [mainContactId])
  mainContactId String

  /// First and Lastname as extra fields only for this order. The main contact is not sufficient here
  /// fields are used for example for tracking notifications
  firstName     String?
  lastName      String?

  /// We can disable tracking notifications on user, order and package level
  trackingNotificationsEnabled    Boolean @default(true)

  language Language  @default(DE)
  packages Package[]

  shippingAddress   Address? @relation("orderShippingAddresses", fields: [shippingAddressId], references: [id], onDelete: Cascade)
  shippingAddressId String?
  billingAddress    Address? @relation("orderBillingAddresses", fields: [billingAddressId], references: [id], onDelete: Cascade)
  billingAddressId  String?

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String
  payments Payment[]

  saleorOrders          SaleorOrder[]
  zohoSalesOrders       ZohoSalesOrder[]
  xentralProxyAuftraege XentralProxyAuftrag[]

  invoices Invoice[]

  @@unique([orderNumber, tenantId])
  // Adding this unique constraint just for relational purposes
  @@unique([id, orderNumber])
  @@index([shippingAddressId])
  @@index([billingAddressId])
  @@index([shippingPriceTaxId])
  @@index([orderNumber])
  @@index([orderStatus])
  @@index([date])
  @@index([shipmentStatus])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([tenantId])
  @@index([mainContactId])
}

enum CountryCode {
  AD
  AE
  AF
  AG
  AI
  AL
  AM
  AO
  AQ
  AR
  AS
  AT
  AU
  AW
  AX
  AZ
  BA
  BB
  BD
  BE
  BF
  BG
  BH
  BI
  BJ
  BL
  BM
  BN
  BO
  BQ
  BR
  BS
  BT
  BV
  BW
  BY
  BZ
  CA
  CC
  CD
  CF
  CG
  CH
  CI
  CK
  CL
  CM
  CN
  CO
  CR
  CU
  CV
  CW
  CX
  CY
  CZ
  DE
  DJ
  DK
  DM
  DO
  DZ
  EC
  EE
  EG
  EH
  ER
  ES
  ET
  EU
  FI
  FJ
  FK
  FM
  FO
  FR
  GA
  GB
  GD
  GE
  GF
  GG
  GH
  GI
  GL
  GM
  GN
  GP
  GQ
  GR
  GS
  GT
  GU
  GW
  GY
  HK
  HM
  HN
  HR
  HT
  HU
  ID
  IE
  IL
  IM
  IN
  IO
  IQ
  IR
  IS
  IT
  JE
  JM
  JO
  JP
  KE
  KG
  KH
  KI
  KM
  KN
  KP
  KR
  KW
  KY
  KZ
  LA
  LB
  LC
  LI
  LK
  LR
  LS
  LT
  LU
  LV
  LY
  MA
  MC
  MD
  ME
  MF
  MG
  MH
  MK
  ML
  MM
  MN
  MO
  MP
  MQ
  MR
  MS
  MT
  MU
  MV
  MW
  MX
  MY
  MZ
  NA
  NC
  NE
  NF
  NG
  NI
  NL
  NO
  NP
  NR
  NU
  NZ
  OM
  PA
  PE
  PF
  PG
  PH
  PK
  PL
  PM
  PN
  PR
  PS
  PT
  PW
  PY
  QA
  RE
  RO
  RS
  RU
  RW
  SA
  SB
  SC
  SD
  SE
  SG
  SH
  SI
  SJ
  SK
  SL
  SM
  SN
  SO
  SR
  SS
  ST
  SV
  SX
  SY
  SZ
  TC
  TD
  TF
  TG
  TH
  TJ
  TK
  TL
  TM
  TN
  TO
  TR
  TT
  TV
  TW
  TZ
  UA
  UG
  UM
  US
  UY
  UZ
  VA
  VC
  VE
  VG
  VI
  VN
  VU
  WF
  WS
  YE
  YT
  ZA
  ZM
  ZW
}

// The ECI internal Address model. Most values are optional, as we can have
// addresses like "ABHOLUNG" or others
model Address {
  // eci internal id
  id        String   @id
  // Created and updated at the ECI DB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Optional information, if this address is the default for a certain contact.
  /// This information can be used by some systems like Zoho
  isDefault   Boolean? 

  street                String?
  additionalAddressLine String?
  plz                   String?
  city                  String?
  countryCode           CountryCode?
  countryArea           String?
  company               String?
  phone                 String?
  fullname              String?

  /// Optional field
  houseNumber           String?
  streetWithoutHouseNumber  String?

  /// One address can have multiple contacts connected to it.
  /// Sometimes, you have orders from different email addresses, sending to the same address..
  contact   Contact[]


  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  /// A unique string identifying this address for easy lookup
  normalizedName String

  /// An array of zoho addresses. Can be multiple if the same address is synced to different zoho apps
  zohoAddress ZohoAddress[]

  /// An array of orders where this address is used as the shipping address
  shippingAddressInOrders Order[] @relation("orderShippingAddresses")
  /// An array of orders where this address is used as the billing address
  billingAddressInOrders  Order[] @relation("orderBillingAddresses")

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
  @@index([id])
  @@index([updatedAt])
}

// The ECI internal Product model
// We use the ProductVariant more, as only variants have unique identifier like the SKU. Products can be matched only via the product name
model Product {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name            String
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName  String
  // the HS-Code (Zolltarifnummer)
  hsCode          String?
  // Where the product was produced. Important only for customs/tariffs
  countryOfOrigin CountryCode?

  variants ProductVariant[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

// The ECI internal ProductVariant Model. One product can have one ore many Product Variants
model ProductVariant {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Old product variants get disabled
  active Boolean @default(true)

  sku         String
  // Some systems don't have a specific variant name
  // but just a single variant. Variant Name is therefore optional
  variantName String?
  ean         String?

  /// The weight in KG for this product variant
  weight      Float?

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  defaultWarehouse   Warehouse? @relation(fields: [defaultWarehouseId], references: [id], onDelete: Cascade)
  defaultWarehouseId String?

  /// The default tax rate of this article. Might be different for purchase and sales
  salesTax      Tax?    @relation(fields: [salesTaxId], references: [id])
  salesTaxId    String?

  stockEntries StockEntries[]

  orderLineItem OrderLineItem[]

  packagelineItem PackageLineItem[]

  zohoItem ZohoItem[]

  xentralArtikel XentralArtikel[]

  saleorProductVariant SaleorProductVariant[]

  // Available physical stock over all warehouses
  stockOnHand Int?

  // if this product variant is a bundle / composite product
  isBundleProduct      Boolean          @default(false)

  /// if this product is actually a "just-in-time" bundle, not a composite item.
  /// normally, product bundles don't allocate stock on the individual products
  isProductBundle     Boolean           @default(false)
  // A product variant can be a bundle product and can
  // have just one Bill of Material related
  billOfMaterial       BillOfMaterial[]
  /// deprecated
  billOfMaterialChilds BillOfMaterial[] @relation("childProduct")

  @@unique([sku, tenantId])
  // Just for relational purposes
  @@unique([id, sku])
  @@index([productId])
  @@index([tenantId])
  @@index([salesTaxId])
  @@index([defaultWarehouseId])
}

model BillOfMaterial {
  // eci internal id
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productVariant   ProductVariant @relation(references: [id], fields: [productVariantId], onDelete: Cascade)
  productVariantId String

  // The product variant
  part   ProductVariant @relation("childProduct", references: [id], fields: [partId], onDelete: Cascade)
  partId String

  /// Product parts can have a order in which they appear. Is an optional information
  order    Int?
  quantity Int

  @@unique([productVariantId, partId])
  @@index([tenantId])
  @@index([productVariantId])
  @@index([partId])
}

/// Carriers can have different names in Xentral - depending on the manually created shipping zone. We have to match them to our internal carrier
/// This is a manually created mapping table.
model XentralCarrier {
  id String @id @default(cuid())
  eciCarrier  Carrier
  name        String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  @@index([eciCarrier])
  @@index([name])
  @@index([xentralProxyAppId])

}

model XentralArtikel {
  /// Xentral Internal ID
  id String

  xentralNummer String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])
  productVariantId String

  @@unique([id, xentralProxyAppId])
  @@unique([xentralNummer, xentralProxyAppId])
  @@index([id])
  @@index([xentralProxyAppId])
  @@index([productVariantId])
}

model XentralLieferschein {
  /// Xentral Internal ID
  id Int

  status String

  xentralBelegNr String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  @@unique([id, xentralProxyAppId])
  @@unique([xentralBelegNr, xentralProxyAppId])
  @@index([xentralProxyAppId])
  @@index([id])
  @@index([packageId])
}

model StockEntries {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  /// Physical stock entries; Stock, that is commited in not finished orders
  actualCommittedStock        Int @default(0)
  /// Total stock in this warehouse right now
  actualAvailableStock        Int @default(0)
  /// Total stock that is not commited and ready for sale
  actualAvailableForSaleStock Int @default(0)

  @@unique([warehouseId, productVariantId, tenantId])
  @@index([productVariantId])
  @@index([warehouseId])
  @@index([tenantId])
}

/// Internal model to store braintree payment gateway settings for tenants
model BraintreeApp {
  id String @id

  enabled Boolean @default(true)

  sandbox Boolean @default(false)

  merchantId String
  publicKey  String
  // Encrypt before writing to the DB!
  privateKey String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  cronSchedule String @default("*/30 * * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  braintreeTransactions BraintreeTransaction[]

  @@index([enabled])
  @@index([tenantId])
}

model BraintreeTransaction {
  /// The Braintree internal ID
  id String

  createdAt DateTime
  updatedAt DateTime

  /// If this braintree transaction is a paypal payment, we store the paypal transaction id as well
  payPalTransactionId String?

  status String?

  braintreeApp   BraintreeApp @relation(fields: [braintreeAppId], references: [id], onDelete: Cascade)
  braintreeAppId String

  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String

  @@unique([id, braintreeAppId])
  @@index([braintreeAppId])
  @@index([paymentId])
}

enum PackageState {
  // Initial state when the package is created
  INIT
  // The carrier has received the shipment info and is about to pick up the package.
  INFORMATION_RECEIVED
  // The shipment has been accepted and is in transit now.
  IN_TRANSIT
  // The carrier is on its way to deliver the shipment.
  OUT_FOR_DELIVERY
  // The carrier attemptet to deliver the shipment but failed. It ususlly leavesa notice and will try to deliver again.
  FAILED_ATTEMPT
  // The shipment has been delivered successfully.
  DELIVERED
  // The package has arrived at the nearest pickup point and is available for pickup.
  AVAILABLE_FOR_PICKUP
  // Held at customs, undelivered, returned to sender, or any other shipping exceptions.
  EXCEPTION
  // The shipment has expired as the carrier didn't return the tracking info for the lat 30 days.
  EXPIRED
  // The shipment is pending as the carrier didn't return the tracking info.
  PENDING
}

enum Carrier {
  DPD
  DHL
  UPS
  HERMES
  PICKUP
  UNKNOWN
  /// Used for Bulk actions
  BULK
}

model ElasticCluster {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  endpoint String
  username String
  password String

  // Send logs to a specific index
  index String?

  elasticLogDrainIntegrations ElasticLogDrainIntegration[]
}

model VercelLogDrainApp {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  configurationId String  @unique
  installationId  String  @unique
  projectId       String? @unique
  teamId          String?
  userId          String

  webhooks IncomingWebhook[]

  elasticLogDrainIntegrations ElasticLogDrainIntegration[]
}

model ElasticLogDrainIntegration {
  id               String            @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled          Boolean           @default(true)
  subscription     Subscription?     @relation(fields: [subscriptionId], references: [id])
  subscriptionId   String?           @unique
  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId         String
  logDrainApp      VercelLogDrainApp @relation(fields: [logDrainAppId], references: [id])
  logDrainAppId    String            @unique
  elasticCluster   ElasticCluster    @relation(fields: [elasticClusterId], references: [id])
  elasticClusterId String            @unique
  @@index([tenantId])
}

// The ECI Internal Package model
model Package {
  /// internal id
  id        String       @id
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  /// If this entity is active or got deleted somewhere
  active   Boolean  @default(true)

  carrier   Carrier
  
  /// The package shipment state
  state     PackageState @default(INIT)

  /// A unique identifier for this package like PKG-0034
  number             String
  /// tracking id from the carrier. Optional, as the package can, exist before we created a tracking number
  trackingId         String?
  /// A link to the carriers tracking page
  carrierTrackingUrl String?
  order              Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId            String
  events             PackageEvent[]

  /// Line Items in this package
  packageLineItems PackageLineItem[]

  zohoPackage         ZohoPackage[]
  saleorPackage       SaleorPackage[]
  xentralLieferschein XentralLieferschein[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([number, tenantId])
  @@index([trackingId])
  @@index([orderId])
  @@index([tenantId])
  @@index([createdAt])
}

model PackageEvent {
  id        String              @id
  // When the event happened
  time      DateTime
  state     PackageState
  // What happened
  // eg: "The shipment has cleared customs"
  message   String?
  package   Package             @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String
  // `Nürnberg, Deutschland` for example
  location  String?
  sentEmail TransactionalEmail?
  @@index([packageId])
}

model TransactionalEmail {
  id             String       @id
  time           DateTime
  email          String
  // Sendgrid returns a unique id for each email
  sentEmailId    String
  // The related package event that caused this email to be sent
  packageEvent   PackageEvent @relation(fields: [packageEventId], references: [id])
  packageEventId String       @unique
}

model TrackingEmailApp {
  id                String                @id
  tenant            Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId          String
  sendgridTemplates SendgridTemplate[]
  defaultLanguage   Language
  sender            String
  replyTo           String
  integration       TrackingIntegration[]
  @@index([tenantId])
}

enum Language {
  DE
  EN
}

model SendgridTemplate {
  // internal id
  id                 String           @id
  // A human readable name provided by the user
  // To use internationalized emails you should prefix the name with the language code
  name               String
  packageState       PackageState?
  language           Language
  // Localized subject for the email
  subject            String
  // The template id in sendgrid
  templateId         String
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id], onDelete: Cascade)
  trackingEmailAppId String

  @@unique([trackingEmailAppId, language, packageState])
}

model DpdApp {
  id                    String               @id
  name                  String?
  tenant                Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId              String               @unique
  integration           TrackingIntegration? @relation(fields: [integrationId], references: [id])
  integrationId         String?
  webhooks              IncomingWebhook[]
  trackingIntegrationId String?

  @@index([integrationId])
}

/// EasyPost Model
model EasyPostApp {
  id            String               @id
  name          String?
  apiKey        String
  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId      String               @unique
  webhooks      IncomingWebhook[]
  integration   TrackingIntegration? @relation(fields: [integrationId], references: [id])
  integrationId String?

  @@index([integrationId])
}

/// DHL Tracking App model
model DHLTrackingApp {
  id            String               @id

  enabled       Boolean @default(false)

  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId      String               @unique
  /// From the developer portal. Is different for sandbox and prod
  apiKey        String

  trackingIntegration           TrackingIntegration? @relation(fields: [trackingIntegrationId], references: [id])
  trackingIntegrationId         String?

  cronSchedule String @default("0 */4 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  @@index([trackingIntegrationId])


}

model ProductDataFeedApp {
  id String @id

  // Graphql endpoint of a saleor app
  productDetailStorefrontURL String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration ProductDataFeedIntegration?

  @@index([tenantId])
}

model LogisticsApp {
  id String @id

  // The custom view ID use to get all current orders
  currentOrdersCustomViewId String

  // Regular orders in the next fice days custom view
  nextFiveDaysOrdersCustomViewId String

  // The custom view ID to get all current bulk orders
  currentBulkOrdersCustomViewId String

  // custom view ID to get all bulk orders for the next days
  nextFiveDaysBulkOrdersCustomViewId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration LogisticsIntegration?

}

model ZohoApp {
  id String @id

  enabled Boolean @default(true)

  orgId        String
  clientId     String
  clientSecret String
  /// Set the datacenter of this ZohoApp. One of: ".com" | ".eu" | ".in" | ".com.au" | ".jp";
  datacenter   String   @default(".eu")
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId     String
  /// The language, that this org is set to. Some API fields like the country name work with translated names, so we need to know the orgs language
  orgLanguage  Language @default(DE)

  /// the cf_api name from Zoho Settings of the custom field
  customFieldReadyToFulfill String?
  /// the cf_api name from Zoho Settings of the custom field
  customFieldVoucherCode   String?
  /// the cf_api name from Zoho Settings of the custom field used to save a note to the customer
  customFieldCustomerNote   String?

  /// the cf_api name for Zoho settings of the custom field used to enable or disable tracking notifications
  customFieldTrackingNotifications  String?

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  // We can create the needed bull jobs for every sync entity, that is enabled
  syncContacts      Boolean @default(false)
  syncWarehouses    Boolean @default(false)
  syncOrders        Boolean @default(false)
  syncInvoices      Boolean @default(false)
  syncPayments      Boolean @default(false)
  syncProductStocks Boolean @default(false)
  syncProducts      Boolean @default(false)
  syncPackages      Boolean @default(false)
  syncTaxes         Boolean @default(false)

  strapiToZohoIntegrations StrapiToZohoIntegration[]
  logisticsIntegrations    LogisticsIntegration[]
  trackingIntegrations     TrackingIntegration[]

  webhooks              IncomingWebhook[]
  saleorZohoIntegration SaleorZohoIntegration[]
  zohoPayments          ZohoPayment[]
  zohoItems             ZohoItem[]
  zohoWarehouses        ZohoWarehouse[]
  zohoContacts          ZohoContact[]
  zohoInvoices          ZohoInvoice[]
  zohoSalesOrder        ZohoSalesOrder[]
  zohoPackageLineItems  ZohoPackageLineItem[]
  zohoOrderLineItems    ZohoOrderLineItem[]
  zohoTaxes             ZohoTax[]
  zohoContactPersons    ZohoContactPerson[]
  zohoAddresses         ZohoAddress[]
  zohoPackages          ZohoPackage[]
  zohoAccounts          ZohoBankAccount[]

  @@index([tenantId])
  @@index([enabled])
}

// Saleor Apps are separate applications that use GraphQL to talk to a Saleor
// server and receive webhooks with event notifications from Saleor.
// Every tenant can have multiple saleor apps which correspond to different
// saleor instances. Per saleor instance and channel we have just one SaleorApp (we use the shop domain as identification)
model SaleorApp {
  id String @id

  // The domain of a running saleor instance.
  // You can prefix with http:// or https:// if you want.
  // If no protocol is specified, https:// is assumed.
  domain String

  name String

  installedSaleorApps InstalledSaleorApp[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([domain, tenantId])
  // Just for relational purposes
  @@unique([id, domain])
  @@index([tenantId])
}

// All ECI Integrations for Saleor should be handled as individual Apps that could be installed via the Marketplace for example
// And the different AppTypes have different settings / webhooks / permissions
enum SaleorAppType {
  productdatafeed
  zohointegration
  mailchimpintegration
  paymentgatewaybanktransfer
  paymentgatewaybraintree
}

// We can have different Installed Saleor Apps for the same Saleor instance. We also have one Installed Saleor App per Channel
model InstalledSaleorApp {
  // The saleor application id
  // This is the id for the app on saleor's side and can be used in queries and
  // mutations to identify the app.
  id String @id

  // should be made mandatory later.
  type SaleorAppType?

  cronSchedule String @default("*/30 * * * *")

  // The order prefix we use to identify orders coming from this Saleor.
  orderPrefix String @default("STORE")

  // Every SaleorApp can have multiple webhooks configured.
  // One webhook can fire on multiple events. But for sync webhooks, we need a different one
  webhooks IncomingWebhook[]

  /// The default warehouse is always used, when warehouse information is missing for example for packages or items
  defaultWarehouse    Warehouse? @relation(fields: [defaultWarehouseId], references: [id])
  defaultWarehouseId  String?

  // Unlike regular users, Saleor Apps use a bearer token. The token is
  // assigned at App installation time and needs to be stored in a secure manner.
  // The authorization header for Apps has the following format:
  // Authorization: Bearer <app-token>
  token String

  channelSlug String?

  saleorApp   SaleorApp @relation(fields: [saleorAppId, domain], references: [id, domain], onDelete: Cascade)
  saleorAppId String
  domain      String

  cookies Cookies[]

  saleorZohoIntegration SaleorZohoIntegration[]

  productDataFeedIntegration ProductDataFeedIntegration[]
  saleorPayment              SaleorPayment[]
  saleorPaymentGateway       SaleorPaymentGateway[]
  saleorProductVariant       SaleorProductVariant[]
  saleorWarehouse            SaleorWarehouse[]
  saleorOrder                SaleorOrder[]
  saleorOrderLineItem        SaleorOrderLineItem[]
  saleorFulfilmentLines      SaleorFulfillmentLine[]
  saleorPackage              SaleorPackage[]

  @@unique([domain, channelSlug])
  @@index([saleorAppId, domain])
  @@index([defaultWarehouseId])
}

// One tenant per company
// Every tenant can have multiple connections with every integration.
model Tenant {
  id String @id

  // Human readable identifier
  name String

  subscriptions Subscription[]

  // App configurations
  saleorApps                  SaleorApp[]
  zohoApps                    ZohoApp[]
  productdatafeedApps         ProductDataFeedApp[]
  strapiApps                  StrapiApp[]
  productDataFeedIntegrations ProductDataFeedIntegration[]
  strapiToZohoIntegrations    StrapiToZohoIntegration[]
  logisticsIntegrations       LogisticsIntegration[]
  logisticsApps               LogisticsApp[]
  trackingEmailApps           TrackingEmailApp[]
  dpdApps                     DpdApp[]
  trackingIntegrations        TrackingIntegration[]
  elasticLogDrainIntegration  ElasticLogDrainIntegration[]
  xentralProxyApp             XentralProxyApp[]
  order                       Order[]
  contact                     Contact[]
  company                     Company[]
  saleorZohoIntegration       SaleorZohoIntegration[]
  product                     Product[]
  productVariant              ProductVariant[]
  payment                     Payment[]
  paymentMethods              PaymentMethod[]
  warehouse                   Warehouse[]
  invoice                     Invoice[]
  orderLineItem               OrderLineItem[]
  packageLineItem             PackageLineItem[]
  braintree                   BraintreeApp[]
  tax                         Tax[]
  package                     Package[]
  stockEntries                StockEntries[]
  addresses                   Address[]
  billOfMaterial              BillOfMaterial[]
  easyPost                    EasyPostApp[]
  DHLTrackingApps             DHLTrackingApp[]
}

// A subscription indicates a tenant has payed for one integration.
model Subscription {
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  payedUntil DateTime?

  productDataFeedIntegration ProductDataFeedIntegration?
  strapiToZohoIntegration    StrapiToZohoIntegration?
  logisticsIntegration       LogisticsIntegration?
  trackingIntegration        TrackingIntegration?
  elasticLogDrainIntegration ElasticLogDrainIntegration[]
  saleorZohoIntegration      SaleorZohoIntegration[]
  xentralProxyApp            XentralProxyApp[]

  @@index([tenantId])
}

// ----------------------------------------------------------------------------
// Integrations
//
// Every integration is a connection between application configurations and a tenant
// ----------------------------------------------------------------------------

model TrackingIntegration {
  id                 String           @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled            Boolean          @default(true)
  subscription       Subscription?    @relation(fields: [subscriptionId], references: [id])
  subscriptionId     String?          @unique
  tenant             Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId           String
  dpdApps            DpdApp[]
  dhlTrackingApps    DHLTrackingApp[]
  easyPostApps       EasyPostApp[]
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id])
  trackingEmailAppId String
  zohoApp            ZohoApp?         @relation(fields: [zohoAppId], references: [id])
  zohoAppId          String?
  @@index([zohoAppId])
  @@index([trackingEmailAppId])
  @@index([tenantId])
}

model ProductDataFeedIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productDataFeedApp   ProductDataFeedApp @relation(fields: [productDataFeedAppId], references: [id])
  productDataFeedAppId String             @unique

  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id])
  installedSaleorAppId String?
  @@index([installedSaleorAppId])
  @@index([tenantId])
}

enum CronJobStatus {
  success
  failure
}

// CronJobs / Sync Job model to store the state of synchronisation
// Use the "cronstate" handler to access data in this model
model CronJobState {
  // Generated in this schema: TENANTID_APPID_ENTITY -> Entity is contacts / items / ...
  //                                      ^-- For example the ZohoAppId or the installedSaleorAppId
  id            String         @id
  lastRun       DateTime?
  lastRunStatus CronJobStatus?
  /// You can lock cron runs to prevent running in parallel for sensitive services like Xentral
  locked        Boolean @default(false)
}

// The saleor zoho integration consists of several, individual sync jobs
// The code is located in the "integration-entity-sync-saleor" and "integration-entity-sync-zoho"
// - from both sides to the internal ECI database and from the ECI database to the other system
// a customer can make settings here.
model SaleorZohoIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  // The order prefix we use in Zoho to identify orders coming from Saleor
  orderPrefix String @default("STORE")

  // We can create the needed bull jobs for every sync entity, that is enabled
  syncContacts      Boolean @default(false)
  syncWarehouses    Boolean @default(false)
  syncOrders        Boolean @default(false)
  syncInvoices      Boolean @default(false)
  syncPayments      Boolean @default(false)
  syncProductStocks Boolean @default(false)
  syncProducts      Boolean @default(false)
  syncPackages      Boolean @default(false)
  syncTaxes         Boolean @default(false)

  // How frequent the synchronisation should run. Default once per hour.
  cronScheduleZoho   String @default("*/30 * * * *")
  cronScheduleSaleor String @default("*/30 * * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeoutZoho    Int    @default(800)
  cronTimeoutSaleor  Int    @default(600)

  @@index([enabled])
}

model LogisticsIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  logisticsApp   LogisticsApp @relation(fields: [logisticsAppId], references: [id])
  logisticsAppId String       @unique

  @@index([tenantId])
  @@index([zohoAppId])
}

model StrapiToZohoIntegration {
  id         String    @id
  payedUntil DateTime?
  enabled    Boolean   @default(true)

  // The Content type of BulkOrders
  strapiContentType String @default("bulkorder")

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId    String
  strapiApp   StrapiApp @relation(fields: [strapiAppId], references: [id])
  strapiAppId String    @unique
  zohoApp     ZohoApp   @relation(fields: [zohoAppId], references: [id])
  zohoAppId   String
}

// Every tenant can have multiple strapi instances
model StrapiApp {
  id String @id

  name     String
  webhooks IncomingWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  integration StrapiToZohoIntegration?
  @@index([tenantId])
}

model XentralProxyApp {
  id String @id

  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  username  String
  password  String
  projectId Int
  url       String

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  syncOrders        Boolean @default(false)
  syncProducts      Boolean @default(false)
  syncPackages      Boolean @default(false)

  xentralProxyAuftraege XentralProxyAuftrag[]
  xentralArtikel        XentralArtikel[]
  XentralLieferscheine  XentralLieferschein[]
  xentralCarrier        XentralCarrier[]

  @@index([tenantId])
  @@index([enabled])
  @@index([warehouseId])
  @@index([subscriptionId])

}

model XentralProxyAuftrag {
  /// Xentral internal ID
  id             Int
  xentralBelegNr String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  /// The status in Xentral
  status  String? 

  @@unique([id, xentralProxyAppId])
  @@unique([xentralBelegNr, xentralProxyAppId])
  @@index([orderId])
  @@index([xentralProxyAppId])
}

// ----------------------------------------------------------------------------
// Every Config/App can have multiple webhooks attached
// ----------------------------------------------------------------------------

model IncomingWebhook {
  id        String     @id
  // Human readable name
  name      String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  secret    SecretKey?

  // Webhook Connections
  dpdApp               DpdApp?             @relation(fields: [dpdAppId], references: [id], onDelete: Cascade)
  dpdAppId             String?
  easyPostApp          EasyPostApp?        @relation(fields: [easyPostAppId], references: [id], onDelete: Cascade)
  easyPostAppId        String?
  logisticsApp         LogisticsApp?       @relation(fields: [logisticsAppId], references: [id], onDelete: Cascade)
  logisticsAppId       String?
  productDataFeedApp   ProductDataFeedApp? @relation(fields: [productDataFeedAppId], references: [id], onDelete: Cascade)
  productDataFeedAppId String?
  zohoApp              ZohoApp?            @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId            String?
  strapiApp            StrapiApp?          @relation(fields: [strapiAppId], references: [id], onDelete: Cascade)
  strapiAppId          String?
  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String?
  vercelLogDrainApp    VercelLogDrainApp?  @relation(fields: [vercelLogDrainAppId], references: [id], onDelete: Cascade)
  vercelLogDrainAppId  String?

  @@index([id])
  @@index([dpdAppId])
  @@index([easyPostAppId])
  @@index([vercelLogDrainAppId])
  @@index([zohoAppId])
  @@index([installedSaleorAppId])
  @@index([productDataFeedAppId])
  @@index([strapiAppId])
  @@index([logisticsAppId])
}

model SecretKey {
  id String @id

  // Human readable name
  name      String?
  secret    String
  createdAt DateTime @default(now())

  incomingWebhook   IncomingWebhook @relation(fields: [incomingWebhookId], references: [id], onDelete: Cascade)
  incomingWebhookId String          @unique
}
