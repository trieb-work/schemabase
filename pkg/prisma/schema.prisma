/// our default provider is planetScale/mysql.
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

/// ECI Internal models are prefixed with eci_ - these models store internal data like ECI users
///
model eci_User {
  id String @id @default(cuid())

  /// A user's fullname
  name     String?
  email    String  @unique
  password String?

  /// The tenants, that the user is member of
  eci_User_Tenants eci_User_Tenant[]

  @@index([email])
}

enum eci_User_Tenant_Role {
  MEMBER
  OWNER
}

/// Mapping of user to tenant and their related rights. User tenant membership
model eci_User_Tenant {
  id String @id @default(cuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   eci_User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  role eci_User_Tenant_Role

  @@index([tenantId])
  @@index([userId])
}

/// ECI Internal model to store cookies / additional headers, that
/// might be needed for some apps
model Cookies {
  id String @id @default(cuid())

  key   String
  value String

  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id])
  installedSaleorAppId String?

  @@index([installedSaleorAppId])
}

// ------------------------------------------------------------------------------------------------
//
//  SALEOR SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------

model SaleorProductType {
  /// Saleor Internal Id
  id String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  productType   ProductType @relation(fields: [productTypeId], references: [id], onDelete: Cascade)
  productTypeId String

  @@unique([id, installedSaleorAppId])
  @@index([productTypeId])
  @@index([installedSaleorAppId])
}

model SaleorTaxClass {
  /// Saleor Internal Id
  id String

  /// When an item has no tax rate (for example for historic orders), we use this tax class
  fallback Boolean @default(false)

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  tax   Tax    @relation(fields: [taxId], references: [id], onDelete: Cascade)
  taxId String

  @@unique([id, installedSaleorAppId])
  @@index([taxId])
  @@index([installedSaleorAppId])
}

model SaleorAttribute {
  /// Saleor Internal Id
  id String

  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  attributeId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([attributeId])
  @@index([installedSaleorAppId])
}

enum SaleorOrderStatus {
  DRAFT
  UNFULFILLED
  PARTIALLY_FULFILLED
  CANCELED
  FULFILLED
}

enum SaleorPaymentStatus {
  NOT_CHARGED
  PENDING
  PARTIALLY_CHARGED
  FULLY_CHARGED
  PARTIALLY_REFUNDED
  FULLY_REFUNDED
  REFUSED
  CANCELLED
}

// Saleor specific model for orders.
model SaleorOrder {
  /// Saleor Internal Id
  id String

  /// This order status is mostly used, to make sure, that we do no longer try to create packages for this order
  status SaleorOrderStatus?

  paymentStatus SaleorPaymentStatus?

  createdAt DateTime

  order   Order  @relation(fields: [orderId, orderNumber], references: [id, orderNumber], onDelete: Cascade)
  orderId String

  // The Human-Readable order number. Gets
  // prefixed with something like "STORE-" when moved to Zoho
  orderNumber String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  saleorPayment SaleorPayment[]

  @@unique([id, installedSaleorAppId])
  @@unique([orderId, installedSaleorAppId])
  @@index([orderId])
  @@index([installedSaleorAppId])
  @@index([orderNumber])
  @@index([id])
  @@index([orderId, orderNumber])
}

model SaleorCategory {
  /// Saleor Internal Id
  id String

  // saleor does not provide us this data
  //createdAt DateTime
  //updatedAt DateTime

  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([categoryId])
  @@index([installedSaleorAppId])
  @@index([id])
}

model SaleorCustomer {
  /// Saleor Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  customer   Contact @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([customerId])
  @@index([installedSaleorAppId])
  @@index([id])
}

model SaleorChannel {
  id String

  name String

  /// related, internal sales channel. We map this channel manually in most cases, so this field is optional
  salesChannel   SalesChannel? @relation(fields: [salesChannelId], references: [id], onDelete: Cascade)
  salesChannelId String?

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([salesChannelId])
  @@index([installedSaleorAppId])
}

/// Saleor specific model for channel listing entries for saleor products
model SaleorChannelListing {
  id String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  @@unique([id, installedSaleorAppId])
  @@index([installedSaleorAppId])
}

model SaleorPackage {
  /// Saleor Internal Id
  id String

  createdAt DateTime

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([packageId])
  @@index([installedSaleorAppId])
  @@index([id])
}

// model for saleor fulfillment line items
model SaleorFulfillmentLine {
  /// Saleor Internal Id
  id String

  packagelineItem   PackageLineItem @relation(fields: [packageLineItemId], references: [id], onDelete: Cascade)
  packageLineItemId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([packageLineItemId])
  @@index([installedSaleorAppId])
}

model SaleorOrderLineItem {
  /// Saleor Internal Id
  id String

  orderLineItem   OrderLineItem @relation(fields: [orderLineItemId], references: [id], onDelete: Cascade)
  orderLineItemId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([orderLineItemId])
  @@index([installedSaleorAppId])
}

// Saleor specific model for payments.
model SaleorPayment {
  /// Saleor Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  saleorOrder   SaleorOrder? @relation(fields: [saleorOrderId, installedSaleorAppId], references: [id, installedSaleorAppId])
  saleorOrderId String?

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([paymentId])
  @@index([installedSaleorAppId])
  @@index([saleorOrderId])
  @@index([saleorOrderId, installedSaleorAppId])
}

/// Saleor specific model for media files.
/// sometimes, we get from Saleor just a media URL. This helps 
/// us to check, if we have media already uploaded or not, so thats why id is
/// optional
model SaleorMedia {
  id String?

  /// The URL of the media file
  url String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  media   Media  @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  mediaId String

  @@unique([url, installedSaleorAppId])
  @@index([installedSaleorAppId])
  @@index([mediaId])
}

model SaleorProduct {
  /// Saleor internal product id
  id String

  updatedAt DateTime

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([productId])
  @@index([installedSaleorAppId])
}

// Saleor specific model for product variant.
model SaleorProductVariant {
  /// Saleor internal product variant id
  id String

  /// Saleor internal product Id
  productId String

  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([productVariantId])
  @@index([installedSaleorAppId])
}

// Saleor specific model for warehouse.
model SaleorWarehouse {
  /// Saleor Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
  @@index([installedSaleorAppId])
  @@index([warehouseId])
}

model SaleorPaymentGateway {
  /// Saleor Internal Id
  id String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  paymentMethods PaymentMethod[]

  @@unique([id, installedSaleorAppId])
  @@index([installedSaleorAppId])
}

// ------------------------------------------------------------------------------------------------
//
//  Zoho SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------
// Zoho specific model for item metadata. For simplicity, we don't use a seperate product and product variant table.
model ZohoItem {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([productVariantId])
}

model ZohoPackage {
  /// Zoho Internal Id
  id String

  // Zoho has the entities shipment and package.
  // we track both in this entity
  shipmentId String?

  createdAt DateTime
  updatedAt DateTime

  shipmentStatus String?

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([packageId])
  @@index([id])
  @@index([shipmentStatus])
}

model ZohoContact {
  // Zoho Internal Contact Id
  id String

  // We set these optional, so that we
  // can easily upsert ZohoContactPerson
  createdAt DateTime?
  updatedAt DateTime?

  /// When using the DATEV integration from Zoho Books, this field might come in handy.
  //// Needs customFieldDatevContact in ZohoApp set
  datevId Int?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  zohoContactPerson ZohoContactPerson[]
  zohoSalesOrder    ZohoSalesOrder[]
  zohoAddress       ZohoAddress[]

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
}

// Zoho knows Contacts and ContactPersons.
model ZohoContactPerson {
  /// Zoho Internal ContactPerson Id
  id String

  /// Contacts/Contactpersons can be disabled to filter out merged contacts
  active Boolean @default(true)

  /// Just one Zoho Contact Person can be primary
  isPrimary Boolean @default(false)

  zohoContact   ZohoContact @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId String

  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId String
  // For easy look-up directly in the ZohoContact model. Is set automatically from related contact 
  email     String?

  // zohoPayments ZohoPayment[]

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  // zohoInvoices    ZohoInvoice[]
  zohoSalesOrders ZohoSalesOrder[]

  @@unique([id, zohoAppId])
  @@index([contactId])
  @@index([zohoContactId])
  @@index([zohoContactId, zohoAppId])
  @@index([zohoAppId])
  @@index([active])
  @@index([isPrimary])
  @@index([id])
}

model ZohoAddress {
  /// Zoho internal Address id
  id String

  address   Address @relation(fields: [addressId], references: [id], onDelete: Cascade)
  addressId String

  /// Zoho Addresses are valid only per zoho contact. Sometimes, we have different
  /// customers with the same address. To not get any issues, we need to store the customer id
  zohoContact   ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId String?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([id])
  @@index([zohoAppId])
  @@index([addressId])
  @@index([zohoContactId, zohoAppId])
}

enum ZohoSalesOrderStatus {
  draft
  confirmed
  fulfilled
  shipped
}

// Zoho specific model.
model ZohoSalesOrder {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  zohoContact   ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  zohoContactId String?

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  /// The ECI internal order ID 
  orderId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  zohoContactPerson          ZohoContactPerson? @relation(fields: [zohoContactPersonId, zohoContactPersonZohoAppId], references: [id, zohoAppId])
  zohoContactPersonId        String?
  zohoContactPersonZohoAppId String?

  @@unique([id, zohoAppId])
  @@index([orderId])
  @@index([zohoAppId])
  @@index([id])
  @@index([zohoContactPersonId, zohoContactPersonZohoAppId])
  @@index([zohoContactId, zohoAppId])
}

// Zoho specific model.
model ZohoInvoice {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  // The Zoho Internal Invoice number
  // as complete string: INV-395956
  number String

  // zohoContact   ZohoContact? @relation(fields: [zohoContactId, zohoAppId], references: [id, zohoAppId], onDelete: Cascade)
  // zohoContactId String?

  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  // zohoContactPerson          ZohoContactPerson? @relation(fields: [zohoContactPersonId, zohoContactPersonZohoAppId], references: [id, zohoAppId])
  // zohoContactPersonId        String?
  // zohoContactPersonZohoAppId String?

  @@unique([id, zohoAppId])
  @@unique([number, zohoAppId])
  @@index([zohoAppId])
  @@index([invoiceId])
}

/// Zoho specific model.
model ZohoPayment {
  /// Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?  @unique

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([paymentId])
  @@index([zohoAppId])
}

model ZohoBankAccount {
  /// Zoho Internal Bankacount Id

  id String

  name     String
  currency Currency
  active   Boolean  @default(true)

  paymentMethod   PaymentMethod? @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId String?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([paymentMethodId])
}

model ZohoWarehouse {
  /// Zoho Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([zohoAppId])
  @@index([warehouseId])
}

model ZohoTax {
  /// internal ID of tax in Zoho
  id String

  tax   Tax    @relation(fields: [taxId], references: [id], onDelete: Cascade)
  /// ID of eci internal Tax Object
  taxId String

  /// The name could be used to match a tax better when multiple taxes exist
  name String?

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([id])
  @@index([zohoAppId])
  @@index([taxId])
}

model ZohoOrderLineItem {
  /// Zoho Internal Id
  id String

  orderLineItem   OrderLineItem @relation(fields: [orderLineItemId], references: [id], onDelete: Cascade)
  orderLineItemId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  @@unique([id, zohoAppId])
  @@index([orderLineItemId])
  @@index([zohoAppId])
}

model ZohoPackageLineItem {
  /// Zoho Internal Id
  id String

  packagelineItem   PackageLineItem @relation(fields: [packagelineItemId], references: [id], onDelete: Cascade)
  packagelineItemId String

  zohoApp         ZohoApp        @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId       String
  orderLineItem   OrderLineItem? @relation(fields: [orderLineItemId], references: [id])
  orderLineItemId String?

  @@unique([id, zohoAppId])
  @@index([packagelineItemId])
  @@index([zohoAppId])
  @@index([orderLineItemId])
}

// ------------------------------------------------------------------------------------------------
//
//  ECI INTERNAL ENTITY MODELS
//
// ------------------------------------------------------------------------------------------------

// The ECI internal invoice model
model Invoice {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Un-Prefixed Invoice Number (e.g. 30994)
  // Invoice-Numbers have to be unique per Tenant!
  // We use them as unique identifier between systems
  invoiceNumber     String
  invoiceTotalGross Float
  invoiceCurrency   Currency

  payments Payment[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  orders      Order[]
  zohoInvoice ZohoInvoice[]

  /// The person who has created this Invoice (In other systems this can also be a Useraccount)
  mainContact   Contact? @relation(references: [id], fields: [mainContactId])
  mainContactId String?

  @@unique([invoiceNumber, tenantId])
  @@index([invoiceNumber])
  @@index([tenantId])
  @@index([mainContactId])
}

enum DatevContactType {
  DEBITOR
  KREDITOR
}

// DATEV model for debitoren, kreditoren
model DatevContact {
  // we set the internal database id in this case!
  id String @id

  /// The datev ID has to follow the DATEV rules: for SKR04 10000-69999 = debitoren, 
  /// 70000-99999 = Kreditoren
  datevNummer Int

  type DatevContactType

  contact   Contact @relation(references: [id], fields: [contactId], onDelete: Cascade)
  contactId String

  datevApp   DatevApp @relation(references: [id], fields: [datevAppId], onDelete: Cascade)
  datevAppId String

  @@index([contactId])
  @@index([datevAppId])
}

/// ==================================================== ///////

// Internal model to save taxes information
model Tax {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  // Lowercase, trim, whitespace remove, special characters remove etc.
  normalizedName String
  /// default tax percentage.
  percentage     Float?

  /// An array of orders where this tax is used as the tax for the shipping method
  shippingTaxInOrders Order[]
  /// An array of lineitems where this tax is used as the tax for the line item
  taxInLineItems      OrderLineItem[]

  productVariants ProductVariant[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoTaxes        ZohoTax[]
  saleorTaxClasses SaleorTaxClass[]

  @@unique([normalizedName, tenantId])
  @@unique([percentage, tenantId])
  @@index([percentage])
  @@index([tenantId])
}

enum PaymentStatus {
  /// The payment is not yet processed
  pending
  /// The amount is authorized but not captured yet
  authorized
  /// The payment is processed / captured / charged
  paid
  /// The payment is refunded
  refunded
  /// The payment is partially refunded
  partiallyRefunded
  /// The payment is cancelled
  cancelled
}

/// The ECI internal payments model
model Payment {
  /// eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Unique identifier for a customer payment. We use the payment gateway id as reference.
  referenceNumber String

  /// A payment can be just a payment profile id
  paymentProfileId String?

  /// The order date. You can also create an order in the past for example. 
  /// Some systems just use a date here
  date DateTime?

  amount Float

  /// The status of the payment. We have default status paid, as we currently work only with paid payments
  status PaymentStatus @default(paid)

  /// The currency of the payment. We use the ISO 4217 standard here
  currency Currency?

  /// Costs for this transaction, for example bank charges, gateway charges, paypal charges
  transactionFee Float @default(0)

  metadata String?

  /// We store the encrypted echeck data for example here (among other payment data that might be needed). 
  metadataJson Json?

  order   Order?  @relation(fields: [orderId], references: [id])
  orderId String?

  /// The person who has created this Payment (In other systems this can also be a Useraccount)
  mainContact   Contact? @relation(references: [id], fields: [mainContactId])
  mainContactId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  paymentMethod   PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  paymentMethodId String

  invoices Invoice[]

  zohoPayment           ZohoPayment[]
  saleorPayment         SaleorPayment[]
  braintreeTransactions BraintreeTransaction[]
  kencoveApiPayments    KencoveApiPayment[]

  @@unique([referenceNumber, tenantId])
  @@index([orderId])
  @@index([tenantId])
  @@index([paymentMethodId])
  @@index([mainContactId])
  @@index([orderId, tenantId])
}

/// categorize payments by payment method type
enum PaymentMethodType {
  paypal
  card
  /// banktransfer = Vorkasse = prepayment
  banktransfer
  echeck
}

/// categorize payments by gateway type
enum GatewayType {
  braintree
  paypal
  stripe
  /// banktransfer = Vorkasse
  banktransfer
  authorizeNet
}

/// Internal representation of payment methods. We try to normalize different payment types to more generic ones.
model PaymentMethod {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  gatewayType GatewayType
  methodType  PaymentMethodType
  currency    Currency

  saleorPaymentGateway                     SaleorPaymentGateway? @relation(fields: [saleorPaymentGatewayId, saleorPaymentGatewayInstalledSaleorAppId], references: [id, installedSaleorAppId], onDelete: Cascade)
  saleorPaymentGatewayId                   String?
  saleorPaymentGatewayInstalledSaleorAppId String?

  /// One internal payment method can have multiple Zoho Bank Accounts. Internally, we know for example just "banktransfer" but in Zoho we might have multiple
  /// bank Accounts
  zohoBankAccounts ZohoBankAccount[]

  payments Payment[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([gatewayType, methodType, currency, tenantId])
  @@index([tenantId])
  @@index([saleorPaymentGatewayId, saleorPaymentGatewayInstalledSaleorAppId])
}

model Company {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  // Lowercase, trim, whitespace remove, special characters remove etc.
  normalizedName String

  contacts Contact[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

/// The ECI internal contact model. One contact has one E-Mail address only. E-Mail addresses are unique per tenant. In some systems the Contact is equal to Users or Accounts
model Contact {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Email is our unique identifier. Emails have to be valid and can be very long, so we use a Text field here
  email String @db.VarChar(500)

  firstName String?
  lastName  String?

  phone String?

  /// a different, global identifier that can be used to identify a contact in other systems.
  /// we set this for example in saleor as external identifier
  externalIdentifier String?

  /// a different, global identifier that can be used to identify a contact in other systems.
  externalIdentifier2 String?

  /// is this contact a customer / debitor? Can be customer and/or vendor
  customer Boolean @default(true)

  /// is this contact a vendor / kreditor? Can be customer and/or vendor
  vendor Boolean @default(false)

  orders   Order[]
  invoices Invoice[]
  payments Payment[]

  /// A Contact can be related to one company
  company   Company? @relation(fields: [companyId], references: [id])
  companyId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoContactPersons ZohoContactPerson[]
  datevContacts      DatevContact[]
  addresses          Address[]
  saleorCustomers    SaleorCustomer[]
  kencoveApiContacts KencoveApiContact[]
  awsCognitoUsers    AWSCognitoUser[]

  /// Customers can be related to one or multiple sales channels.
  /// Depending on the setup, this means, that customers are allowed to use specific pricelists
  channels SalesChannel[]

  /// If we have the users permission to send tracking emails
  trackingEmailsConsent   Boolean @default(true)
  /// If we have the users consent to send marketing emails
  marketingEmailsConstent Boolean @default(false)

  @@unique([email, tenantId])
  @@index([companyId])
  @@index([tenantId])
  @@index([email])
}

// The ECI internal Warehouse model.
model Warehouse {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName String

  tenant              Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId            String
  zohoWarehouse       ZohoWarehouse[]
  saleorWarehouse     SaleorWarehouse[]
  xentralProxyApp     XentralProxyApp[]
  installedSaleorApp  InstalledSaleorApp[]
  kencoveApiWarehouse KencoveApiWarehouse[]

  packageLineItems     PackageLineItem[]
  orderLineItems       OrderLineItem[]
  stockEntries         StockEntries[]
  isDefaultWarehouseOf ProductVariant[]

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

enum Currency {
  EUR
  USD
}

// The ECI internal LineItem model
model OrderLineItem {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique string to identify this LineItem
  // between different systems. For orders:
  // ${orderNumber}${sku}${quantity}
  // For invoices: ${invoiceNumber}${sku}${quantity}
  // For packages: ${packageNumber}${sku}${quantity} 
  uniqueString String

  /// The order of this line item in the order. Starts with 1
  itemOrder Int?

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String

  quantity Float
  sku      String
  tax      Tax?    @relation(fields: [taxId], references: [id], onDelete: Cascade)
  taxId    String?

  // Warehouse, this line item corresponds to.
  // Warehouse can be undefined, as we have non-inventory products as well.
  warehouse   Warehouse? @relation(fields: [warehouseId], references: [id])
  warehouseId String?

  /// The total net price (price excluding taxes) of all line item. Optional, as we might have just one of the two values on hand
  totalPriceNet   Float?
  /// The total gross price (price including taxes) of all line item. Optional, as we might have just one of the two values on hand
  totalPriceGross Float?

  unitPriceNet   Float?
  unitPriceGross Float?

  undiscountedTotalPriceGross Float?

  /// The unit net price (price excluding taxes) of one line item. Optional, as we might have just one of the two values on hand
  undiscountedUnitPriceNet   Float?
  /// The unit gross price (price including taxes) of one line item. Optional, as we might have just one of the two values on hand
  undiscountedUnitPriceGross Float?

  undiscountedTotalPriceNet Float?

  /// The disount amount, that is applied to the net price (discount excluding taxes).
  discountValueNet Float @default(0)
  /// The disount amount, that is applied to the gross price (discount including taxes).
  //discountValueGross Float @default(0)

  productVariant   ProductVariant @relation(fields: [productVariantId, sku], references: [id, sku])
  productVariantId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoPackageLineItems ZohoPackageLineItem[]
  saleorOrderLineItems SaleorOrderLineItem[]
  zohoOrderLineItems   ZohoOrderLineItem[]
  metadata             Metadata[]

  @@unique([uniqueString, tenantId])
  @@index([id])
  @@index([orderId])
  @@index([productVariantId])
  @@index([warehouseId])
  @@index([uniqueString])
  @@index([tenantId])
  @@index([sku])
  @@index([productVariantId, sku])
  @@index([taxId])
}

/// a generic metadata model, that can be attached to different entities
model Metadata {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  key   String
  value String @db.Text

  orderLineItem   OrderLineItem? @relation(fields: [orderLineItemId], references: [id], onDelete: Cascade)
  orderLineItemId String?

  tenant   Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String
  order    Order?  @relation(fields: [orderId], references: [id])
  orderId  String?

  @@unique([id, tenantId])
  @@index([orderLineItemId])
  @@index([tenantId])
  @@index([orderId])
}

model PackageLineItem {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique string to identify this LineItem
  // between different systems. See: uniqueStringOrderLine package
  // For packages: ${packageNumber}${sku}${quantity}${order}
  uniqueString String

  // order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  // orderId String

  // Warehouse, this line item corresponds to.
  // Warehouse can be undefined, as we have non-inventory products as well.
  warehouse   Warehouse? @relation(fields: [warehouseId], references: [id])
  warehouseId String?

  package   Package? @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String?

  quantity       Float
  sku            String
  // TODO changed fields from productVariantId, sku to tenantId, sku because these fields already exist and will it more easy during creation
  productVariant ProductVariant @relation(fields: [tenantId, sku], references: [tenantId, sku])

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoPackageLineItems    ZohoPackageLineItem[]
  saleorFulfillmentsLines SaleorFulfillmentLine[]

  @@unique([uniqueString, tenantId])
  // @@index([orderId])
  @@index([packageId])
  @@index([warehouseId])
  @@index([uniqueString])
  @@index([tenantId])
  @@index([sku])
  @@index([tenantId, sku])
}

enum OrderStatus {
  draft
  unconfirmed
  confirmed
  // The order is fulfilled + paid -> finished
  closed
  canceled
}

enum OrderPaymentStatus {
  unpaid
  fullyPaid
  partiallyPaid
  fullyRefunded
  partiallyRefunded
}

enum OrderShipmentStatus {
  pending
  partiallyShipped
  shipped
  delivered
}

enum OrderInvoiceStatus {
  notInvoiced
  invoiced
}

// The ECI internal Order model.

model Order {
  // eci internal id
  id        String   @id
  // Created and updated at the ECI DB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// The order date. You can also create an order in the past for example. 
  /// Some systems just use a date here
  date DateTime

  /// The Date, that we expect this order to be shipped.
  expectedShippingDate DateTime?

  /// The expected shipment carrier for this order
  carrier Carrier?

  /// Add messages, that will be printed on order and shipping documents for the customer. We are hitting text limits  strangely, so we added @db.Text
  customerNote String? @db.Text

  orderStatus    OrderStatus         @default(draft)
  paymentStatus  OrderPaymentStatus  @default(unpaid)
  shipmentStatus OrderShipmentStatus @default(pending)
  invoiceStatus  OrderInvoiceStatus  @default(notInvoiced)

  /// In PuF: if the Order is not readyToFullfill it woll not get transfered to logistics partner (kramer); default is false
  readyToFullfill Boolean @default(false)

  /// An order token, that can be used to pull this order unauthenticated.
  /// can be manually set, but we also use a cuid by default
  token String? @default(cuid())

  /// Order-Numbers have to be unique per Tenant!
  /// We use them as unique identifier between systems
  orderNumber     String
  /// if source system has a second ID which is benefitial to the user, we can provide it here
  referenceNumber String?

  orderLineItems OrderLineItem[]

  shippingPriceNet   Float?
  shippingPriceGross Float?
  shippingPriceTax   Tax?    @relation(fields: [shippingPriceTaxId], references: [id], onDelete: Cascade)
  shippingPriceTaxId String?
  /// the exact name of the shipping method
  shippingMethodName String?
  /// an ID identifier for the shipping method
  shippingMethodId   String? @db.Text

  /// The applied discount code
  discountCode String?

  /// The disount amount, that is applied
  /// to the net, undiscounted subtotal price.
  /// Discounts never get applied on shipping costs
  discountValueNet Float @default(0)

  /// The disount percentage, that is applied
  /// to the net, undiscounted subtotal price.
  /// Discounts never get applied on shipping costs
  discountValueNetPercentage Float @default(0)

  // The final, total price
  totalPriceNet   Float?
  totalPriceGross Float

  currency Currency @default(EUR)

  /// The person who has created this Order (In other systems this can also be a Useraccount)
  mainContact   Contact @relation(references: [id], fields: [mainContactId])
  mainContactId String

  /// First and Lastname as extra fields only for this order. The main contact is not sufficient here
  /// fields are used for example for tracking notifications
  firstName String?
  lastName  String?

  /// We can disable tracking notifications on user, order and package level
  trackingNotificationsEnabled Boolean @default(true)

  language Language  @default(DE)
  packages Package[]

  shippingAddress   Address? @relation("orderShippingAddresses", fields: [shippingAddressId], references: [id], onDelete: Cascade)
  shippingAddressId String?
  billingAddress    Address? @relation("orderBillingAddresses", fields: [billingAddressId], references: [id], onDelete: Cascade)
  billingAddressId  String?

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String
  payments Payment[]

  saleorOrders          SaleorOrder[]
  zohoSalesOrders       ZohoSalesOrder[]
  xentralProxyAuftraege XentralProxyAuftrag[]
  kencoveApiOrders      KencoveApiOrder[]

  metadata Metadata[]

  invoices Invoice[]

  @@unique([orderNumber, tenantId])
  // Adding this unique constraint just for relational purposes
  @@unique([id, orderNumber])
  @@index([id, orderNumber])
  @@index([id])
  @@index([shippingAddressId])
  @@index([billingAddressId])
  @@index([shippingPriceTaxId])
  @@index([orderNumber])
  @@index([orderStatus])
  @@index([date])
  @@index([shipmentStatus])
  @@index([paymentStatus])
  @@index([createdAt])
  @@index([tenantId])
  @@index([mainContactId])
  @@index([token])
}

/// The schemabase internal sales channel model.
/// We use channels to offer different availabilities and prices for different products
/// you can map for example saleor sales channels to this model and pricelists from different
/// ERP systems
model SalesChannel {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  normalizedName String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  contacts       Contact[]
  saleorChannels SaleorChannel[]
  priceEntries   SalesChannelPriceEntry[]

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
}

model SalesChannelPriceEntry {
  id String @id

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salesChannel     SalesChannel   @relation(fields: [salesChannelId], references: [id], onDelete: Cascade)
  salesChannelId   String
  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])
  productVariantId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  price Float

  startDate DateTime?
  endDate   DateTime?

  /// This price is valid starting with this quantity
  minQuantity             Float                     @default(0)
  KencoveApiPricelistItem KencoveApiPricelistItem[]

  @@unique([salesChannelId, productVariantId, tenantId, minQuantity, startDate, endDate])
  @@index([salesChannelId])
  @@index([productVariantId])
  @@index([tenantId])
}

enum CountryCode {
  AD
  AE
  AF
  AG
  AI
  AL
  AM
  AO
  AQ
  AR
  AS
  AT
  AU
  AW
  AX
  AZ
  BA
  BB
  BD
  BE
  BF
  BG
  BH
  BI
  BJ
  BL
  BM
  BN
  BO
  BQ
  BR
  BS
  BT
  BV
  BW
  BY
  BZ
  CA
  CC
  CD
  CF
  CG
  CH
  CI
  CK
  CL
  CM
  CN
  CO
  CR
  CU
  CV
  CW
  CX
  CY
  CZ
  DE
  DJ
  DK
  DM
  DO
  DZ
  EC
  EE
  EG
  EH
  ER
  ES
  ET
  EU
  FI
  FJ
  FK
  FM
  FO
  FR
  GA
  GB
  GD
  GE
  GF
  GG
  GH
  GI
  GL
  GM
  GN
  GP
  GQ
  GR
  GS
  GT
  GU
  GW
  GY
  HK
  HM
  HN
  HR
  HT
  HU
  ID
  IE
  IL
  IM
  IN
  IO
  IQ
  IR
  IS
  IT
  JE
  JM
  JO
  JP
  KE
  KG
  KH
  KI
  KM
  KN
  KP
  KR
  KW
  KY
  KZ
  LA
  LB
  LC
  LI
  LK
  LR
  LS
  LT
  LU
  LV
  LY
  MA
  MC
  MD
  ME
  MF
  MG
  MH
  MK
  ML
  MM
  MN
  MO
  MP
  MQ
  MR
  MS
  MT
  MU
  MV
  MW
  MX
  MY
  MZ
  NA
  NC
  NE
  NF
  NG
  NI
  NL
  NO
  NP
  NR
  NU
  NZ
  OM
  PA
  PE
  PF
  PG
  PH
  PK
  PL
  PM
  PN
  PR
  PS
  PT
  PW
  PY
  QA
  RE
  RO
  RS
  RU
  RW
  SA
  SB
  SC
  SD
  SE
  SG
  SH
  SI
  SJ
  SK
  SL
  SM
  SN
  SO
  SR
  SS
  ST
  SV
  SX
  SY
  SZ
  TC
  TD
  TF
  TG
  TH
  TJ
  TK
  TL
  TM
  TN
  TO
  TR
  TT
  TV
  TW
  TZ
  UA
  UG
  UM
  US
  UY
  UZ
  VA
  VC
  VE
  VG
  VI
  VN
  VU
  WF
  WS
  YE
  YT
  ZA
  ZM
  ZW
}

// The ECI internal Address model. Most values are optional, as we can have
// addresses like "ABHOLUNG" or others
model Address {
  // eci internal id
  id        String   @id
  // Created and updated at the ECI DB
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Optional information, if this address is the default for a certain contact.
  /// This information can be used by some systems like Zoho
  isDefault Boolean?

  street                String?
  additionalAddressLine String?
  plz                   String?
  city                  String?
  countryCode           CountryCode?
  company               String?
  phone                 String?
  fullname              String?
  /// The state of the address. This is not the country, but the state of the country. Like NY
  state                 String?

  /// Optional field
  houseNumber              String?
  streetWithoutHouseNumber String?

  /// One address can have multiple contacts connected to it.
  /// Sometimes, you have orders from different email addresses, sending to the same address..
  contact Contact[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  /// A unique string identifying this address for easy lookup
  normalizedName String @db.VarChar(300)

  /// An array of zoho addresses. Can be multiple if the same address is synced to different zoho apps
  zohoAddress ZohoAddress[]

  kencoveApiAddress KencoveApiAddress[]

  /// An array of orders where this address is used as the shipping address
  shippingAddressInOrders Order[] @relation("orderShippingAddresses")
  /// An array of orders where this address is used as the billing address
  billingAddressInOrders  Order[] @relation("orderBillingAddresses")

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
  @@index([id])
  @@index([updatedAt])
}

enum AttributeType {
  DROPDOWN
  MULTISELECT
  FILE
  PRODUCT_REFERENCE
  VARIANT_REFERENCE
  NUMERIC
  RICH_TEXT
  PLAIN_TEXT
  /// Swatch is a special type of dropdown, where the values are represented as colors
  SWATCH
  BOOLEAN
  DATE
  DATE_TIME
}

model Attribute {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  /// normalized attribute name for internal mapping
  normalizedName String
  type           AttributeType

  /// Is the attribute mandatory to be set, or can it be left blank
  required Boolean? @default(false)

  /// An understandable slug
  slug String?

  /// Values for product attributes
  productValues        AttributeValueProduct[]
  /// Values for variant attributes
  productVariantValues AttributeValueVariant[]

  productTypeAttributes ProductTypeAttribute[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  kencoveApiAttributes KencoveApiAttribute[]
  saleorAttributes     SaleorAttribute[]

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
  @@index([normalizedName])
}

enum MediaPlacementType {
  /// for example a category banner
  BANNER
  THUMBNAIL
  /// A product manual for example
  MANUAL
  PRODUCTVIDEO
  PRODUCTIMAGE
}

/// model to store image and other media urls for products, variants, categories etc.
/// the URL is the unique identifier for the media
model Media {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // we can mark media as deleted, so that we don't try to upload them again
  deleted Boolean @default(false)

  /// The url of the media
  url String

  type MediaPlacementType? @default(PRODUCTIMAGE)

  /// The tenant this media belongs to
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  products        Product[]
  productVariants ProductVariant[]
  categories      Category[]
  saleorMedia     SaleorMedia[]

  @@unique([url, tenantId])
  @@index([tenantId])
}

/// attributes values for attributes. We have to separate models for product and variant attributes,
/// This model is used to store values for product attributes
model AttributeValueProduct {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Represent value of the attribute value, like text string. When hexColor is additionally used, you always need a string value as well
  /// When attribute is multiselect/dropdown, we have one entry per value 
  value String

  /// color values for swatch attributes
  hexColor String?

  /// We always set a normalized name for the attribute value. For example, if the value is the hex code for red, we set "red" as the normalized name
  normalizedName String

  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  attributeId String

  /// When attribute is a product attribute, this relation is set
  product   Product @relation(fields: [productId], references: [id])
  productId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([productId, attributeId, normalizedName, tenantId])
  @@index([attributeId])
  @@index([tenantId])
  @@index([productId])
}

/// attributes values for attributes. We have to separate models for product and variant attributes,
/// This model is used to store values for variant attributes
model AttributeValueVariant {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Represent value of the attribute value, like text string. 
  /// When hexColor is additionally used, you always need a string value as well
  /// When the attribute type is "reference", we use the id of the referenced product or variant 
  value String @db.Text

  /// color values for swatch attributes
  hexColor String?

  /// We always set a normalized name for the attribute value. For example, if the value is the hex code for red, we set "red" as the normalized name
  normalizedName String

  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  attributeId String

  /// When attribute is a variant attribute, this relation is set
  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])
  productVariantId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([productVariantId, attributeId, normalizedName, tenantId])
  @@index([attributeId])
  @@index([tenantId])
  @@index([productVariantId])
}

/// Product tags are used to group products together. 
/// They are not hierarchical, but flat. You can use generic tags like "Sale" or "New" or "Bestseller"
model ProductTag {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// The name of the tag
  name String

  /// The normalized name of the tag
  normalizedName String

  /// The tenant this tag belongs to
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  /// The products that are tagged with this tag
  products Product[]

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
  @@index([id])
  @@index([updatedAt])
}

/// The ECI internal category model. Product categories are used to group products together
/// and to create a product hierarchy. Categories can be nested
model Category {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// The name of the category
  name String

  /// The normalized name of the category
  normalizedName String

  /// The slug of the category
  slug String?

  /// if possible, the nesting level of this category, starting with 0
  level Int?

  /// The parent category of this category
  parentCategory Category? @relation("CategoryParentCategory", fields: [parentCategoryId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  /// The id of the parent category
  parentCategoryId String?

  /// The children categories of this category
  childrenCategories Category[] @relation("CategoryParentCategory")

  /// The products in this category
  products Product[]

  /// Is this category active or not. Old categories can be disabled
  active Boolean @default(true)

  /// The description text of the category as HTML
  descriptionHTML String? @db.Text

  /// The tenant this category belongs to
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  /// The kencove categories this category is synced to
  kencoveApiCategories KencoveApiCategory[]

  // The saleor categories this category is synced to
  saleorCategories SaleorCategory[]

  media Media[]

  @@unique([slug, tenantId])
  @@index([tenantId])
  @@index([id])
  @@index([parentCategoryId])
}

/// Product Types are like templates for products. They define which attributes a product has
/// and if a product has variants
model ProductType {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// e.g., "Shirt", "Energizer", etc.
  name                   String
  normalizedName         String
  /// Indicates if products of this type have variants
  isVariant              Boolean
  products               Product[]
  /// Links to the attributes that belong to this product type. This relational table defines also if attributes are variant selection attributes or not
  attributes             ProductTypeAttribute[]
  saleorProductTypes     SaleorProductType[]
  kencoveApiProductTypes KencoveApiProductType[]
  tenant                 Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId               String

  @@unique([normalizedName, tenantId])
  @@unique([id, tenantId])
  @@index([tenantId])
}

/// matching table between product types and attributes
model ProductTypeAttribute {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productTypeId String

  /// Indicates if the attribute is for product or variant.
  isForVariant Boolean

  /// Indicates if it's a "variant selection" attribute for multi-variant products, for example size or color
  isVariantSelection Boolean

  productType ProductType @relation(fields: [productTypeId], references: [id])
  attribute   Attribute   @relation(fields: [attributeId], references: [id])
  attributeId String

  @@unique([productTypeId, attributeId]) // Ensures an attribute can be linked only once per product type
  @@index([attributeId])
}

/// This model defines the relation between a variant and a related variant,
/// frequently bought together. So this is on variant level
model VariantToFrequentlyBoughtWith {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  variantId        String
  relatedVariantId String

  variant        ProductVariant @relation("VariantToRelated", fields: [variantId], references: [id])
  relatedVariant ProductVariant @relation("RelatedToVariant", fields: [relatedVariantId], references: [id])

  @@id([variantId, relatedVariantId])
  @@index([relatedVariantId])
  @@index([variantId])
}

/// This model defines the relation between a product and a related product,
/// frequently bought together. So this is on product level
model ProductToFrequentlyBoughtWith {
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  productId        String
  relatedProductId String

  product        Product @relation("ProductToRelated", fields: [productId], references: [id])
  relatedProduct Product @relation("RelatedToProduct", fields: [relatedProductId], references: [id])

  @@id([productId, relatedProductId])
  @@index([relatedProductId])
  @@index([productId])
}

// The ECI internal Product model
// We use the ProductVariant more, as only variants have unique identifier like the SKU. Products can be matched only via the product name
model Product {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Old products get disabled - this would normally set them to unavailable for purchase
  active Boolean @default(true)

  name            String
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName  String
  // the HS-Code (Zolltarifnummer)
  hsCode          String?
  // Where the product was produced. Important only for customs/tariffs
  countryOfOrigin CountryCode?

  variants      ProductVariant[]
  tags          ProductTag[]
  productType   ProductType?     @relation(fields: [productTypeId], references: [id])
  productTypeId String?

  /// The category this product belongs to
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  categoryId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  saleorProducts        SaleorProduct[]
  saleorChannelListings SaleorChannelListing[]
  kencoveApiProducts    KencoveApiProduct[]

  descriptionHTML String? @db.Text

  attributes AttributeValueProduct[]

  media Media[]

  /// All frequently bought together products as relation
  frequentlyBoughtWith ProductToFrequentlyBoughtWith[] @relation("ProductToRelated")
  /// Just the relation back. Not used in the code
  boughtTogetherWith   ProductToFrequentlyBoughtWith[] @relation("RelatedToProduct")

  @@unique([normalizedName, tenantId])
  @@index([tenantId])
  @@index([categoryId])
  @@index([productTypeId])
  @@index([updatedAt])
}

// The ECI internal ProductVariant Model. One product can have one ore many Product Variants
model ProductVariant {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Old product variants get disabled
  active Boolean @default(true)

  sku         String
  // Some systems don't have a specific variant name
  // but just a single variant. Variant Name is therefore optional
  variantName String?
  ean         String?

  /// The weight in KG for this product variant
  weight Float?

  /// Weight in pounds
  weightLb Float?

  /// Product rating based on customer reviews from services like reviews.io
  averageRating Float?
  /// Number of ratings for this product variant
  ratingCount   Int?

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  /// schemabase internal productId
  productId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  /// The default warehouse to assosiate stocks with. 
  defaultWarehouse   Warehouse? @relation(fields: [defaultWarehouseId], references: [id], onDelete: Cascade)
  defaultWarehouseId String?

  /// The default tax rate of this article. Might be different for purchase and sales
  salesTax   Tax?    @relation(fields: [salesTaxId], references: [id])
  salesTaxId String?

  stockEntries StockEntries[]

  orderLineItem OrderLineItem[]

  packagelineItem PackageLineItem[]

  zohoItem ZohoItem[]

  xentralArtikel XentralArtikel[]

  saleorProductVariant SaleorProductVariant[]

  kencoveApiProductVariant KencoveApiProductVariant[]

  attributes AttributeValueVariant[]

  /// the price entries of this variant. Can have different prices
  /// for different sales channels, quantities and dates
  salesChannelPriceEntries SalesChannelPriceEntry[]

  // Available physical stock over all warehouses
  stockOnHand Int?

  // if this product variant is a bundle / composite product
  isBundleProduct Boolean @default(false)

  /// if this product is actually a "just-in-time" bundle, not a composite item.
  /// normally, product bundles don't allocate stock on the individual products
  isProductBundle      Boolean          @default(false)
  // A product variant can be a bundle product and can
  // have just one Bill of Material related
  billOfMaterial       BillOfMaterial[]
  /// deprecated
  billOfMaterialChilds BillOfMaterial[] @relation("childProduct")

  media Media[]

  /// All frequently bought together products as relation
  frequentlyBoughtWith VariantToFrequentlyBoughtWith[] @relation("VariantToRelated")
  /// Just the relation back. Not used in the code
  boughtTogetherWith   VariantToFrequentlyBoughtWith[] @relation("RelatedToVariant")

  @@unique([sku, tenantId])
  // Just for relational purposes
  @@unique([id, sku])
  @@index([productId])
  @@index([tenantId])
  @@index([salesTaxId])
  @@index([defaultWarehouseId])
}

model BillOfMaterial {
  // eci internal id
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productVariant   ProductVariant @relation(references: [id], fields: [productVariantId], onDelete: Cascade)
  productVariantId String

  // The product variant
  part   ProductVariant @relation("childProduct", references: [id], fields: [partId], onDelete: Cascade)
  partId String

  /// Product parts can have a order in which they appear. Is an optional information
  order    Int?
  quantity Int

  @@unique([productVariantId, partId])
  @@index([tenantId])
  @@index([productVariantId])
  @@index([partId])
}

/// Carriers can have different names in Xentral - depending on the manually created shipping zone. We have to match them to our internal carrier
/// This is a manually created mapping table.
model XentralCarrier {
  id         String  @id @default(cuid())
  eciCarrier Carrier
  name       String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  @@index([eciCarrier])
  @@index([name])
  @@index([xentralProxyAppId])
}

model XentralArtikel {
  /// Xentral Internal ID
  id String

  xentralNummer String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id])
  productVariantId String

  @@unique([id, xentralProxyAppId])
  @@unique([xentralNummer, xentralProxyAppId])
  @@index([id])
  @@index([xentralProxyAppId])
  @@index([productVariantId])
}

model XentralLieferschein {
  /// Xentral Internal ID
  id Int

  status String

  xentralBelegNr String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  @@unique([id, xentralProxyAppId])
  @@unique([xentralBelegNr, xentralProxyAppId])
  @@index([xentralProxyAppId])
  @@index([id])
  @@index([packageId])
}

model StockEntries {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  /// Physical stock entries; Stock, that is commited in not finished orders
  actualCommittedStock        Int @default(0)
  /// Total stock in this warehouse right now
  actualAvailableStock        Int @default(0)
  /// Total stock that is not commited and ready for sale
  actualAvailableForSaleStock Int @default(0)

  @@unique([warehouseId, productVariantId, tenantId])
  @@index([productVariantId])
  @@index([warehouseId])
  @@index([tenantId])
}

/// Internal model to store braintree payment gateway settings for tenants
model BraintreeApp {
  id String @id

  enabled Boolean @default(true)

  sandbox Boolean @default(false)

  merchantId String
  publicKey  String
  // Encrypt before writing to the DB!
  privateKey String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  cronSchedule String @default("*/30 * * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  braintreeTransactions BraintreeTransaction[]

  @@index([enabled])
  @@index([tenantId])
}

model BraintreeTransaction {
  /// The Braintree internal ID
  id String

  createdAt DateTime
  updatedAt DateTime

  /// If this braintree transaction is a paypal payment, we store the paypal transaction id as well
  payPalTransactionId String?

  status String?

  braintreeApp   BraintreeApp @relation(fields: [braintreeAppId], references: [id], onDelete: Cascade)
  braintreeAppId String

  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String

  @@unique([id, braintreeAppId])
  @@index([braintreeAppId])
  @@index([paymentId])
}

enum PackageState {
  // Initial state when the package is created
  INIT
  // The carrier has received the shipment info and is about to pick up the package.
  INFORMATION_RECEIVED
  // The shipment has been accepted and is in transit now.
  IN_TRANSIT
  // The carrier is on its way to deliver the shipment.
  OUT_FOR_DELIVERY
  // The carrier attemptet to deliver the shipment but failed. It ususlly leavesa notice and will try to deliver again.
  FAILED_ATTEMPT
  // The shipment has been delivered successfully.
  DELIVERED
  // The package has arrived at the nearest pickup point and is available for pickup.
  AVAILABLE_FOR_PICKUP
  // Held at customs, undelivered, returned to sender, or any other shipping exceptions.
  EXCEPTION
  // The shipment has expired as the carrier didn't return the tracking info for the lat 30 days.
  EXPIRED
  // The shipment is pending as the carrier didn't return the tracking info.
  PENDING
}

enum Carrier {
  DPD
  DHL
  UPS
  HERMES
  PICKUP
  FEDEX
  USPS
  UNKNOWN
  /// Used for Bulk actions
  BULK
}

model ElasticCluster {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  endpoint String
  username String
  password String

  // Send logs to a specific index
  index String?

  elasticLogDrainIntegrations ElasticLogDrainIntegration[]
}

model VercelLogDrainApp {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  configurationId String  @unique
  installationId  String  @unique
  projectId       String? @unique
  teamId          String?
  userId          String

  webhooks IncomingWebhook[]

  elasticLogDrainIntegrations ElasticLogDrainIntegration[]

  @@index([id])
}

model ElasticLogDrainIntegration {
  id               String            @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled          Boolean           @default(true)
  subscription     Subscription?     @relation(fields: [subscriptionId], references: [id])
  subscriptionId   String?           @unique
  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId         String
  logDrainApp      VercelLogDrainApp @relation(fields: [logDrainAppId], references: [id])
  logDrainAppId    String            @unique
  elasticCluster   ElasticCluster    @relation(fields: [elasticClusterId], references: [id])
  elasticClusterId String            @unique

  @@index([tenantId])
  @@index([logDrainAppId])
  @@index([elasticClusterId])
  @@index([subscriptionId])
}

// The ECI Internal Package model
model Package {
  /// internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// If this entity is active or got deleted somewhere
  active Boolean @default(true)

  carrier Carrier

  /// The package shipment state
  state PackageState @default(INIT)

  /// Optional field if this package is part of a multi piece shipment
  isMultiPieceShipment Boolean @default(false)

  /// we can disable live tracking for a package
  isTrackingEnabled Boolean @default(true)

  /// the parcel weight in grams
  weightGrams Int?

  /// A unique identifier for this package like PKG-0034
  number             String
  /// tracking id from the carrier. Optional, as the package can, exist before we created a tracking number
  trackingId         String?
  /// A link to the carriers tracking page
  carrierTrackingUrl String?
  /// The related order to this package
  order              Order?         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId            String?
  events             PackageEvent[]

  /// Line Items in this package
  packageLineItems PackageLineItem[]

  zohoPackage         ZohoPackage[]
  saleorPackage       SaleorPackage[]
  xentralLieferschein XentralLieferschein[]
  kencoveApiPackage   KencoveApiPackage[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([number, tenantId])
  @@index([trackingId])
  @@index([orderId])
  @@index([tenantId])
  @@index([createdAt])
}

model PackageEvent {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // When the event happened
  time      DateTime
  state     PackageState
  // What happened
  // eg: "The shipment has cleared customs"
  message   String?             @db.Text
  package   Package             @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String
  // `Nürnberg, Deutschland` for example
  location  String?
  sentEmail TransactionalEmail?

  @@index([packageId])
}

model TransactionalEmail {
  id             String       @id
  time           DateTime
  email          String
  // Sendgrid returns a unique id for each email
  sentEmailId    String
  // The related package event that caused this email to be sent
  packageEvent   PackageEvent @relation(fields: [packageEventId], references: [id])
  packageEventId String       @unique
}

model TrackingEmailApp {
  id                String                @id
  tenant            Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId          String
  sendgridTemplates SendgridTemplate[]
  defaultLanguage   Language
  sender            String
  replyTo           String
  integration       TrackingIntegration[]

  @@index([tenantId])
}

enum Language {
  DE
  EN
}

model SendgridTemplate {
  // internal id
  id                 String           @id
  // A human readable name provided by the user
  // To use internationalized emails you should prefix the name with the language code
  name               String
  packageState       PackageState?
  language           Language
  // Localized subject for the email
  subject            String
  // The template id in sendgrid
  templateId         String
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id], onDelete: Cascade)
  trackingEmailAppId String

  @@unique([trackingEmailAppId, language, packageState])
}

model DpdApp {
  id                    String               @id
  name                  String?
  tenant                Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId              String               @unique
  integration           TrackingIntegration? @relation(fields: [integrationId], references: [id])
  integrationId         String?
  webhooks              IncomingWebhook[]
  trackingIntegrationId String?

  @@index([integrationId])
}

/// EasyPost Model
model EasyPostApp {
  id            String               @id
  name          String?
  apiKey        String
  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId      String               @unique
  webhooks      IncomingWebhook[]
  integration   TrackingIntegration? @relation(fields: [integrationId], references: [id])
  integrationId String?

  @@index([integrationId])
}

/// DHL Tracking App model
model DHLTrackingApp {
  id String @id

  enabled Boolean @default(false)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique
  /// From the developer portal. Is different for sandbox and prod. API keys are multi-tenant by default
  /// so we might use them for multiple customer
  apiKey   String

  trackingIntegration   TrackingIntegration? @relation(fields: [trackingIntegrationId], references: [id])
  trackingIntegrationId String?

  cronSchedule String @default("0 */4 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  @@index([trackingIntegrationId])
}

/// UPS Tracking App model
model UPSTrackingApp {
  id String @id

  enabled Boolean @default(false)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  /// From the developer portal. Is the same for sandbox and prod. API keys are multi-tenant by default
  /// so we might use them for multiple customer. It is not clear, how much traffic we can produce with one key
  /// Access key only auth is no longer working - we need Oauth2 now
  accessKey String?

  clientId     String
  clientSecret String

  trackingIntegration   TrackingIntegration? @relation(fields: [trackingIntegrationId], references: [id])
  trackingIntegrationId String?

  cronSchedule String @default("0 */4 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  @@index([trackingIntegrationId])
}

/// Fedex Tracking App model
model FedexTrackingApp {
  id String @id

  enabled Boolean @default(false)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  clientId     String
  clientSecret String

  trackingIntegration   TrackingIntegration? @relation(fields: [trackingIntegrationId], references: [id])
  trackingIntegrationId String?

  cronSchedule String @default("0 */4 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  @@index([trackingIntegrationId])
  @@index([tenantId])
}

model UspsTrackingApp {
  id String @id

  enabled Boolean @default(false)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  clientId     String
  clientSecret String

  trackingIntegration   TrackingIntegration? @relation(fields: [trackingIntegrationId], references: [id])
  trackingIntegrationId String?

  cronSchedule String @default("0 */4 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  @@index([trackingIntegrationId])
  @@index([tenantId])
}

model ProductDataFeedApp {
  id String @id

  // Graphql endpoint of a saleor app
  productDetailStorefrontURL String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration ProductDataFeedIntegration?

  @@index([tenantId])
}

// Datev APP
model DatevApp {
  id String @id

  enabled Boolean @default(false)

  cronSchedule String @default("0 0 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  datevContacts DatevContact[]

  @@index([id])
}

model LogisticsApp {
  id String @id

  // The custom view ID use to get all current orders
  currentOrdersCustomViewId String

  // Regular orders in the next fice days custom view
  nextFiveDaysOrdersCustomViewId String

  // The custom view ID to get all current bulk orders
  currentBulkOrdersCustomViewId String

  // custom view ID to get all bulk orders for the next days
  nextFiveDaysBulkOrdersCustomViewId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration LogisticsIntegration?
}

/// The custom app for the kencove api. Using OAuth for authentication
model KencoveApiApp {
  id String @id

  enabled Boolean @default(false)

  cronSchedule String @default("5 * * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  clientId      String
  clientSecret  String
  /// Token endpoint for the OAuth flow
  tokenEndpoint String
  /// The actual api endpoint. Is different for sandbox and prod
  apiEndpoint   String

  /// The EDI endpoint is different and used to transmit orders back to Odoo.
  /// we use the official EDI integration, so this nedpoint will be part of
  // an official Odoo app in the future
  ediEndpoint String?

  /// The scopes we need to access the api. Just comma separated list
  scope String

  /// A user can manually mark categories, that should be skipped when syncing.
  /// This is a comma separated list of category ids
  skipCategories String?

  /// We can set a fallback tax class (just a string here), that will be set, if 
  /// no tax class is given in the api
  fallbackTaxClass String?

  kencoveApiContacts        KencoveApiContact[]
  kencoveApiAddresses       KencoveApiAddress[]
  kencoveApiProductVariants KencoveApiProductVariant[]
  kencoveApiProducts        KencoveApiProduct[]
  kencoveApiAttributes      KencoveApiAttribute[]
  kencoveApiCategories      KencoveApiCategory[]
  kencoveApiPackages        KencoveApiPackage[]
  kencoveApiWarehouses      KencoveApiWarehouse[]
  kencoveApiOrders          KencoveApiOrder[]
  kencoveApiProductTypes    KencoveApiProductType[]
  kencoveApiPayments        KencoveApiPayment[]
  incomingWebhooks          IncomingWebhook[]
  KencoveApiPricelistItem   KencoveApiPricelistItem[]

  @@index([tenantId])
}

model KencoveApiProductType {
  id String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  productType   ProductType @relation(fields: [productTypeId], references: [id], onDelete: Cascade)
  productTypeId String

  @@unique([id, kencoveApiAppId])
  @@index([productTypeId])
  @@index([kencoveApiAppId])
}

model KencoveApiPayment {
  id String

  createdAt DateTime
  updatedAt DateTime

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  payment   Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String

  @@unique([id, kencoveApiAppId])
  @@index([paymentId])
  @@index([kencoveApiAppId])
}

model KencoveApiWarehouse {
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([warehouseId])
  @@index([kencoveApiAppId])
}

model KencoveApiOrder {
  id String

  createdAt DateTime
  updatedAt DateTime

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([orderId])
  @@index([kencoveApiAppId])
  @@index([orderId, kencoveApiAppId])
}

model KencoveApiCategory {
  id String

  createdAt DateTime
  updatedAt DateTime

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String

  @@unique([id, kencoveApiAppId])
  @@index([kencoveApiAppId])
  @@index([categoryId])
  @@index([id])
}

model KencoveApiAttribute {
  id String

  createdAt DateTime
  updatedAt DateTime

  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  attributeId String

  model String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, model, kencoveApiAppId])
  @@index([attributeId])
  @@index([kencoveApiAppId])
}

model KencoveApiPackage {
  id String

  createdAt DateTime
  updatedAt DateTime

  package   Package @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([packageId])
  @@index([kencoveApiAppId])
}

model KencoveApiProduct {
  id String

  createdAt DateTime
  updatedAt DateTime

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([productId])
  @@index([kencoveApiAppId])
  @@index([productId, kencoveApiAppId])
}

/// Kencove custom productVariant model
model KencoveApiProductVariant {
  id String

  createdAt DateTime
  updatedAt DateTime

  /// KENCOVE API product ID - not internal schemabase id
  productId String?

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([productVariantId])
  @@index([kencoveApiAppId])
  @@index([productId])
  @@index([productId, kencoveApiAppId])
}

/// Kencove custom address model. Relation between internal address
/// object and kencove address object
model KencoveApiAddress {
  id String

  createdAt DateTime
  updatedAt DateTime

  address   Address @relation(fields: [addressId], references: [id])
  addressId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id])
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([kencoveApiAppId])
  @@index([addressId])
}

/// Kencove custom customer model. Relation between internal customer
/// object and kencove customer object
model KencoveApiContact {
  id           String
  customerCode String?
  contact      Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId    String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@unique([customerCode, kencoveApiAppId])
  @@index([kencoveApiAppId])
  @@index([contactId])
}

model KencoveApiPricelistItem {
  id String @id

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salesChannelPriceEntry   SalesChannelPriceEntry @relation(fields: [salesChannelPriceEntryId], references: [id], onDelete: Cascade)
  salesChannelPriceEntryId String

  kencoveApiApp   KencoveApiApp @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId String

  @@unique([id, kencoveApiAppId])
  @@index([kencoveApiAppId])
  @@index([salesChannelPriceEntryId])
}

model ReviewsioApp {
  id String @id

  enabled Boolean @default(false)

  /// The store id coming from reviews.io. For example "snocks" or "kencove-com"
  storeId String

  cronSchedule String @default("0 8 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@index([tenantId])
}

model InternalDataApp {
  id String @id

  enabled Boolean @default(false)

  /// The internal data enrichment / cleaning workflows run normally once per day
  cronSchedule String @default("0 1 * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@index([tenantId])
}

model AlgoliaApp {
  id String @id

  enabled Boolean @default(false)

  applicationId String
  apiKey        String

  categoryIndexName String

  syncCategories Boolean @default(false)

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@index([tenantId])
}

/// The admin app for AWS cognito. Using the IAM credentials to authenticate. We store credentials per user pool
model AWSCognitoApp {
  id String @id

  enabled Boolean @default(true)

  accessKeyId     String
  secretAccessKey String

  userPoolId String

  region String

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  users AWSCognitoUser[]

  @@index([tenantId])
}

model AWSCognitoUser {
  /// The cognito "username"
  id String

  contact   Contact @relation(fields: [contactId], references: [id])
  contactId String

  awsCognitoApp   AWSCognitoApp @relation(fields: [awsCognitoAppId], references: [id])
  awsCognitoAppId String

  @@unique([id, awsCognitoAppId])
  @@index([awsCognitoAppId])
  @@index([contactId])
}

model ZohoApp {
  id String @id

  enabled Boolean @default(true)

  orgId        String
  clientId     String
  clientSecret String
  /// Set the datacenter of this ZohoApp. One of: ".com" | ".eu" | ".in" | ".com.au" | ".jp";
  datacenter   String   @default(".eu")
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId     String
  /// The language, that this org is set to. Some API fields like the country name work with translated names, so we need to know the orgs language
  orgLanguage  Language @default(DE)

  /// the cf_api name from Zoho Settings of the custom field
  customFieldReadyToFulfill String?
  /// the cf_api name from Zoho Settings of the custom field
  customFieldVoucherCode    String?
  /// the cf_api name from Zoho Settings of the custom field used to save a note to the customer
  customFieldCustomerNote   String?

  /// the cf_api name for Zoho settings of the custom field used to enable or disable tracking notifications
  customFieldTrackingNotifications String?

  /// the cf_api name where we store the DATEV kreditor / debitor ID, if we have a running datev integration
  customFieldDatevCustomerId String?

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  // We can create the needed bull jobs for every sync entity, that is enabled
  syncContacts      Boolean @default(false)
  syncWarehouses    Boolean @default(false)
  syncOrders        Boolean @default(false)
  syncInvoices      Boolean @default(false)
  syncPayments      Boolean @default(false)
  syncProductStocks Boolean @default(false)
  syncProducts      Boolean @default(false)
  syncPackages      Boolean @default(false)
  syncTaxes         Boolean @default(false)

  logisticsIntegrations LogisticsIntegration[]
  trackingIntegrations  TrackingIntegration[]

  webhooks             IncomingWebhook[]
  zohoPayments         ZohoPayment[]
  zohoItems            ZohoItem[]
  zohoWarehouses       ZohoWarehouse[]
  zohoContacts         ZohoContact[]
  zohoInvoices         ZohoInvoice[]
  zohoSalesOrder       ZohoSalesOrder[]
  zohoPackageLineItems ZohoPackageLineItem[]
  zohoOrderLineItems   ZohoOrderLineItem[]
  zohoTaxes            ZohoTax[]
  zohoContactPersons   ZohoContactPerson[]
  zohoAddresses        ZohoAddress[]
  zohoPackages         ZohoPackage[]
  zohoAccounts         ZohoBankAccount[]

  @@index([tenantId])
  @@index([enabled])
}

// Saleor Apps are separate applications that use GraphQL to talk to a Saleor
// server and receive webhooks with event notifications from Saleor.
// Every tenant can have multiple saleor apps which correspond to different
// saleor instances. Per saleor instance and channel we have just one SaleorApp (we use the shop domain as identification)
model SaleorApp {
  id String @id

  // The domain of a running saleor instance.
  // You can prefix with http:// or https:// if you want.
  // If no protocol is specified, https:// is assumed.
  domain String

  /// the full saleor api url, inclusive /graphql: https://testing--saleor-puf.eu.saleor.cloud/graphql/
  apiUrl String

  name String

  installedSaleorApps InstalledSaleorApp[]

  tenant   Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String?

  @@unique([domain, tenantId])
  @@unique([domain])
  @@unique([apiUrl])
  // Just for relational purposes
  @@unique([id, domain])
  @@index([tenantId])
}

// All ECI Integrations for Saleor should be handled as individual Apps that could be installed via the Marketplace for example
// And the different AppTypes have different settings / webhooks / permissions
enum SaleorAppType {
  productdatafeed
  entitysync
  prepayment
}

// We can have different Installed Saleor Apps for the same Saleor instance. We also have one Installed Saleor App per Channel
model InstalledSaleorApp {
  // The saleor application id
  // This is the id for the app on saleor's side and can be used in queries and
  // mutations to identify the app.
  id String @id

  enabled Boolean @default(true)

  // should be made mandatory later.
  type SaleorAppType?

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  // The order prefix we use to identify orders coming from this Saleor.
  orderPrefix String @default("STORE")

  // Every SaleorApp can have multiple webhooks configured.
  // One webhook can fire on multiple events. But for sync webhooks, we need a different one
  webhooks IncomingWebhook[]

  /// The default warehouse is always used, when warehouse information is missing for example for packages or items
  defaultWarehouse   Warehouse? @relation(fields: [defaultWarehouseId], references: [id])
  defaultWarehouseId String?

  // Unlike regular users, Saleor Apps use a bearer token. The token is
  // assigned at App installation time and needs to be stored in a secure manner.
  // The authorization header for Apps has the following format:
  // Authorization: Bearer <app-token>
  token String

  channelSlug String?

  /// For historic orders and other features, we might need a default
  defaultChannelSlug String?

  saleorApp   SaleorApp @relation(fields: [saleorAppId, domain], references: [id, domain], onDelete: Cascade)
  saleorAppId String
  domain      String

  cookies Cookies[]

  // USER SETTINGS
  syncCustomers                Boolean @default(false)
  syncWarehouses               Boolean @default(false)
  syncOrders                   Boolean @default(false)
  syncInvoices                 Boolean @default(false)
  syncPayments                 Boolean @default(false)
  syncProductStocks            Boolean @default(false)
  syncProducts                 Boolean @default(false)
  syncPackages                 Boolean @default(false)
  syncTaxes                    Boolean @default(false)
  syncCategories               Boolean @default(false)
  syncFrequentlyBoughtTogether Boolean @default(false)
  /// If this is true, we will create orders in Saleor, that we received from 3rd party systems. Needs min. Saleor 3.17. Will only sync orders, where we have customers in Saleor already
  createHistoricOrdes          Boolean @default(false)
  /// Make use of the transaction API instead of the payments API. Mostly used for historic orders import
  useTransactionApi            Boolean @default(false)

  productDataFeedIntegration ProductDataFeedIntegration[]
  saleorPayment              SaleorPayment[]
  saleorPaymentGateway       SaleorPaymentGateway[]
  saleorProductVariant       SaleorProductVariant[]
  saleorWarehouse            SaleorWarehouse[]
  saleorOrder                SaleorOrder[]
  saleorOrderLineItem        SaleorOrderLineItem[]
  saleorFulfilmentLines      SaleorFulfillmentLine[]
  saleorPackage              SaleorPackage[]
  saleorCustomers            SaleorCustomer[]
  saleorCategory             SaleorCategory[]
  saleorProductType          SaleorProductType[]
  saleorAttribute            SaleorAttribute[]
  saleorProduct              SaleorProduct[]
  saleorChannel              SaleorChannel[]
  saleorMedia                SaleorMedia[]
  saleorTaxClass             SaleorTaxClass[]
  saleorChannelListings      SaleorChannelListing[]

  @@unique([domain, channelSlug])
  @@index([saleorAppId, domain])
  @@index([defaultWarehouseId])
  @@index([id])
}

// One tenant per company
// Every tenant can have multiple connections with every integration.
model Tenant {
  id String @id

  // Human readable identifier
  name String

  subscriptions Subscription[]

  // App configurations
  saleorApps                  SaleorApp[]
  zohoApps                    ZohoApp[]
  productdatafeedApps         ProductDataFeedApp[]
  strapiApps                  StrapiApp[]
  productDataFeedIntegrations ProductDataFeedIntegration[]
  logisticsIntegrations       LogisticsIntegration[]
  logisticsApps               LogisticsApp[]
  trackingEmailApps           TrackingEmailApp[]
  dpdApps                     DpdApp[]
  trackingIntegrations        TrackingIntegration[]
  elasticLogDrainIntegration  ElasticLogDrainIntegration[]
  xentralProxyApp             XentralProxyApp[]
  order                       Order[]
  contact                     Contact[]
  company                     Company[]
  product                     Product[]
  productVariant              ProductVariant[]
  payment                     Payment[]
  paymentMethods              PaymentMethod[]
  warehouse                   Warehouse[]
  invoice                     Invoice[]
  orderLineItem               OrderLineItem[]
  packageLineItem             PackageLineItem[]
  braintree                   BraintreeApp[]
  tax                         Tax[]
  package                     Package[]
  stockEntries                StockEntries[]
  addresses                   Address[]
  billOfMaterial              BillOfMaterial[]
  easyPost                    EasyPostApp[]
  DHLTrackingApps             DHLTrackingApp[]
  datevApps                   DatevApp[]
  UPSTrackingApps             UPSTrackingApp[]
  attributes                  Attribute[]
  attributeProductValues      AttributeValueProduct[]
  attributeVariantValues      AttributeValueVariant[]
  rewiewsioApps               ReviewsioApp[]
  eci_User_Tenants            eci_User_Tenant[]
  kencoveApiApps              KencoveApiApp[]
  productTags                 ProductTag[]
  categories                  Category[]
  productTypes                ProductType[]
  media                       Media[]
  salesChannels               SalesChannel[]
  salesChannelPriceEntry      SalesChannelPriceEntry[]
  internalDataApps            InternalDataApp[]
  awsCognitoApps              AWSCognitoApp[]
  algoliaApps                 AlgoliaApp[]
  fedexTrackingApps           FedexTrackingApp[]
  uspsTrackingApps            UspsTrackingApp[]
  Metadata                    Metadata[]
}

// A subscription indicates a tenant has payed for one integration.
model Subscription {
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  payedUntil DateTime?

  productDataFeedIntegration ProductDataFeedIntegration?
  logisticsIntegration       LogisticsIntegration?
  trackingIntegration        TrackingIntegration?
  elasticLogDrainIntegration ElasticLogDrainIntegration[]
  xentralProxyApp            XentralProxyApp[]

  @@index([tenantId])
}

// ----------------------------------------------------------------------------
// Integrations
//
// Every integration is a connection between application configurations and a tenant
// ----------------------------------------------------------------------------

model TrackingIntegration {
  id                 String             @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled            Boolean            @default(true)
  subscription       Subscription?      @relation(fields: [subscriptionId], references: [id])
  subscriptionId     String?            @unique
  tenant             Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId           String
  dpdApps            DpdApp[]
  dhlTrackingApps    DHLTrackingApp[]
  upsTrackingApps    UPSTrackingApp[]
  easyPostApps       EasyPostApp[]
  fedexTrackingApps  FedexTrackingApp[]
  uspsTrackingApps   UspsTrackingApp[]
  trackingEmailApp   TrackingEmailApp   @relation(fields: [trackingEmailAppId], references: [id])
  trackingEmailAppId String
  zohoApp            ZohoApp?           @relation(fields: [zohoAppId], references: [id])
  zohoAppId          String?

  @@index([zohoAppId])
  @@index([trackingEmailAppId])
  @@index([tenantId])
}

model ProductDataFeedIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productDataFeedApp   ProductDataFeedApp @relation(fields: [productDataFeedAppId], references: [id])
  productDataFeedAppId String             @unique

  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id])
  installedSaleorAppId String?

  @@index([installedSaleorAppId])
  @@index([tenantId])
}

enum CronJobStatus {
  success
  failure
}

// CronJobs / Sync Job model to store the state of synchronisation
// Use the "cronstate" handler to access data in this model
model CronJobState {
  // Generated in this schema: TENANTID_APPID_ENTITY -> Entity is contacts / items / ...
  //                                      ^-- For example the ZohoAppId or the installedSaleorAppId
  id            String         @id
  lastRun       DateTime?
  lastRunStatus CronJobStatus?
  /// You can lock cron runs to prevent running in parallel for sensitive services like Xentral
  locked        Boolean        @default(false)

  /// a simple way to let cron jobs stop cracefully instead of retrying them forever. Not all jobs use this counter
  errorCount Int @default(0)

  @@index([id])
}

model LogisticsIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  logisticsApp   LogisticsApp @relation(fields: [logisticsAppId], references: [id])
  logisticsAppId String       @unique

  @@index([tenantId])
  @@index([zohoAppId])
}

// Every tenant can have multiple strapi instances
model StrapiApp {
  id String @id

  name     String
  webhooks IncomingWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@index([tenantId])
}

model XentralProxyApp {
  id String @id

  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  username  String
  password  String
  projectId Int
  url       String

  cronSchedule String @default("*/30 * * * *")
  cronTimeout  Int    @default(800)

  syncOrders   Boolean @default(false)
  syncProducts Boolean @default(false)
  syncPackages Boolean @default(false)

  xentralProxyAuftraege XentralProxyAuftrag[]
  xentralArtikel        XentralArtikel[]
  XentralLieferscheine  XentralLieferschein[]
  xentralCarrier        XentralCarrier[]

  @@index([tenantId])
  @@index([enabled])
  @@index([warehouseId])
  @@index([subscriptionId])
}

model XentralProxyAuftrag {
  /// Xentral internal ID
  id             Int
  xentralBelegNr String

  xentralProxyApp   XentralProxyApp @relation(fields: [xentralProxyAppId], references: [id])
  xentralProxyAppId String

  order   Order  @relation(fields: [orderId], references: [id])
  orderId String

  /// The status in Xentral
  status String?

  @@unique([id, xentralProxyAppId])
  @@unique([xentralBelegNr, xentralProxyAppId])
  @@index([orderId])
  @@index([xentralProxyAppId])
}

// ----------------------------------------------------------------------------
// Every Config/App can have multiple webhooks attached
// ----------------------------------------------------------------------------

model IncomingWebhook {
  id        String     @id
  // Human readable name
  name      String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  secret    SecretKey?

  // Webhook Connections
  dpdApp               DpdApp?             @relation(fields: [dpdAppId], references: [id], onDelete: Cascade)
  dpdAppId             String?
  easyPostApp          EasyPostApp?        @relation(fields: [easyPostAppId], references: [id], onDelete: Cascade)
  easyPostAppId        String?
  logisticsApp         LogisticsApp?       @relation(fields: [logisticsAppId], references: [id], onDelete: Cascade)
  logisticsAppId       String?
  productDataFeedApp   ProductDataFeedApp? @relation(fields: [productDataFeedAppId], references: [id], onDelete: Cascade)
  productDataFeedAppId String?
  zohoApp              ZohoApp?            @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId            String?
  strapiApp            StrapiApp?          @relation(fields: [strapiAppId], references: [id], onDelete: Cascade)
  strapiAppId          String?
  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String?
  vercelLogDrainApp    VercelLogDrainApp?  @relation(fields: [vercelLogDrainAppId], references: [id], onDelete: Cascade)
  vercelLogDrainAppId  String?
  kencoveApiApp        KencoveApiApp?      @relation(fields: [kencoveApiAppId], references: [id], onDelete: Cascade)
  kencoveApiAppId      String?

  @@index([id])
  @@index([dpdAppId])
  @@index([easyPostAppId])
  @@index([vercelLogDrainAppId])
  @@index([zohoAppId])
  @@index([installedSaleorAppId])
  @@index([productDataFeedAppId])
  @@index([strapiAppId])
  @@index([logisticsAppId])
}

model SecretKey {
  id String @id

  // Human readable name
  name      String?
  secret    String
  createdAt DateTime @default(now())

  incomingWebhook   IncomingWebhook @relation(fields: [incomingWebhookId], references: [id], onDelete: Cascade)
  incomingWebhookId String          @unique
}
