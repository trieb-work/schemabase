datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  shadowDatabaseUrl    = env("SHADOW_DATABASE_URL")
  referentialIntegrity = "prisma"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity"]
}

// ------------------------------------------------------------------------------------------------
//
//  SALEOR SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------

// Saleor specific model for orders.
model SaleorOrder {
  // Saleor Internal Id
  id String

  createdAt DateTime

  order   Order  @relation(fields: [orderId, orderNumber], references: [id, orderNumber], onDelete: Cascade)
  orderId String

  // The Human-Readable order number. Gets
  // prefixed with something like "STORE-" when moved to Zoho
  orderNumber String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  saleorPayment SaleorPayment[]

  @@unique([id, installedSaleorAppId])
}

// Saleor specific model for payments.
model SaleorPayment {
  // Saleor Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  saleorOrder   SaleorOrder? @relation(fields: [saleorOrderId], references: [id])
  saleorOrderId String?

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?  @unique

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
}

// Saleor specific model for product variant.
model SaleorProductVariant {
  // Saleor internal product variant id
  id String

  // Saleor internal product Id
  productId String

  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
}

// Saleor specific model for warehouse.
model SaleorWarehouse {
  // Saleor Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String    @unique

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  @@unique([id, installedSaleorAppId])
}

// ------------------------------------------------------------------------------------------------
//
//  Zoho SPECIFIC MODELS
//
// ------------------------------------------------------------------------------------------------
// Zoho specific model for item metadata. For simplicity, we don't use a seperate product and product variant table.
model ZohoItem {
  // Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  productVariant   ProductVariant @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
  productVariantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String


  @@unique([id, zohoAppId])
}

model ZohoContact {
  // Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  // For easy look-up directly in the ZohoContact model,
  // we store the email firstname etc here as well.
  firstName String?
  lastName  String?
  email     String?

  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  contactId String

  zohoPayments ZohoPayment[]

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String

  zohoInvoices ZohoInvoice[]
  zohoSalesOrders ZohoSalesOrder[]

  @@unique([id, zohoAppId])
  
}

// Zoho specific model.
model ZohoSalesOrder {
  // Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  // The Zoho Internal sales order number
  // as complete string: INV-395956
  number String

  zohoContact   ZohoContact? @relation(fields: [zohoContactId], references: [id], onDelete: Cascade)
  zohoContactId String?

  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String @unique

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String


  @@unique([id, zohoAppId])
  @@unique([number, zohoAppId])
}

// Zoho specific model.
model ZohoInvoice {
  // Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  // The Zoho Internal Invoice number
  // as complete string: INV-395956
  number String

  zohoContact   ZohoContact? @relation(fields: [zohoContactId], references: [id], onDelete: Cascade)
  zohoContactId String?

  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  invoiceId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String


  @@unique([id, zohoAppId])
  @@unique([number, zohoAppId])
}

// Zoho specific model.
model ZohoPayment {
  // Zoho Internal Id
  id String

  createdAt DateTime
  updatedAt DateTime

  zohoContact   ZohoContact? @relation(fields: [zohoContactId], references: [id], onDelete: Cascade)
  zohoContactId String?

  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String?  @unique

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String


  @@unique([id, zohoAppId])
}

model ZohoWarehouse {
  // Zoho Internal Id
  id String

  warehouse   Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  warehouseId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId String


  @@unique([id, zohoAppId])
}

// ------------------------------------------------------------------------------------------------
//
//  ECI INTERNAL ENTITY MODELS
//
// ------------------------------------------------------------------------------------------------
// categorize payments by payment type
enum PaymentMethodType {
  paypal
  card
  banktransfer
  braintree
  onlinepayment
  unknown
}

// The ECI internal invoice model
model Invoice {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Un-Prefixed Invoice Number (e.g. 30994)
  // Invoice-Numbers have to be unique per Tenant!
  // We use them as unique identifier between systems
  invoiceNumber String

  payments Payment[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  orders      Order[]
  zohoInvoice ZohoInvoice[]

  @@unique([invoiceNumber, tenantId])
}

// The ECI internal payments model
model Payment {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Unique identifier for a customer payment.
  // We use the payment gateway id as reference.
  referenceNumber String

  amount        Float
  paymentMethod PaymentMethodType

  order   Order?  @relation(fields: [orderId], references: [id])
  orderId String?


  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  invoices Invoice[]

  zohoPayment   ZohoPayment[]
  saleorPayment SaleorPayment[]


  @@unique([orderId, tenantId])
  @@unique([referenceNumber, tenantId])
}

model Company {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  contacts Contact[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  @@unique([name, tenantId])
}

// The ECI internal contact model. One contact has one E-Mail address only.
// E-Mail addresses are unique per tenant
model Contact {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String?
  orders    Order[]

  // A Contact can be related to one company
  company   Company? @relation(fields: [companyId], references: [id])
  companyId String?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoContacts ZohoContact[]

  @@unique([email, tenantId])
}

// The ECI internal Warehouse model.
model Warehouse {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName String

  tenant          Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId        String
  zohoWarehouse   ZohoWarehouse[]
  saleorWarehouse SaleorWarehouse[]

  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
}

enum Currency {
  EUR
  USD
}

// The ECI internal orderline model
model OrderLine {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  order   Order?  @relation(fields: [orderId], references: [id])
  orderId String?

  quantity        Float
  totalPriceGross Float
  totalPriceNet   Float
  currency        Currency @default(EUR)

  productVariant   ProductVariant @relation(fields: [productVariantId, sku], references: [id, sku])
  productVariantId String
  sku              String

}

// The ECI internal Order model.
model Order {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // deprecated!
  externalOrderId String?


  // Order-Numbers have to be unique per Tenant!
  // We use them as unique identifier between systems
  orderNumber String

  // The end customers emails where we send transactional emails to
  contacts Contact[]
  language Language  @default(DE)
  packages Package[]

  orderlines OrderLine[]

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String
  payment  Payment[]

  saleorOrders SaleorOrder[]
  zohoSalesOrders ZohoSalesOrder[]

  invoices Invoice[]

  @@unique([orderNumber, tenantId])
  
}

// The ECI internal Product model
// We use the ProductVariant more, as only variants have unique identifier like the SKU. Products can be matched only via the product name
model Product {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String?
  // Lowercase, trim, whitespace remove, special characters remove
  normalizedName String?

  variants ProductVariant[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  @@unique([name, tenantId])
  @@unique([normalizedName, tenantId])
}

// The ECI internal ProductVariant Model. One product can have one ore many Product Variants
model ProductVariant {
  // eci internal id
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sku String

  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  orderLine OrderLine[]

  zohoItem ZohoItem[]

  saleorProductVariant SaleorProductVariant[]

  @@unique([sku, tenantId])
}

enum PackageState {
  // Initial state when the package is created
  INIT
  // The carrier has received the shipment info and is about to pick up the package.
  INFORMATION_RECEIVED
  // The shipment has been accepted and is in transit now.
  IN_TRANSIT
  // The carrier is on its way to deliver the shipment.
  OUT_FOR_DELIVERY
  // The carrier attemptet to deliver the shipment but failed. It ususlly leavesa notice and will try to deliver again.
  FAILED_ATTEMPT
  // The shipment has been delivered successfully.
  DELIVERED
  // The package has arrived at the nearest pickup point and is available for pickup.
  AVAILABLE_FOR_PICKUP
  // Held at customs, undelivered, returned to sender, or any other shipping exceptions.
  EXCEPTION
  // The shipment has expired as the carrier didn't return the tracking info for the lat 30 days.
  EXPIRED
  // The shipment is pending as the carrier didn't return the tracking info.
  PENDING
}

enum Carrier {
  DPD
  UNKNOWN
}

model ElasticCluster {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  endpoint String
  username String
  password String

  // Send logs to a specific index
  index String?


  elasticLogDrainIntegrations ElasticLogDrainIntegration[]
}

model VercelLogDrainApp {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt


  configurationId String  @unique
  installationId  String  @unique
  projectId       String? @unique
  teamId          String?
  userId          String

  webhooks IncomingWebhook[]

  elasticLogDrainIntegrations ElasticLogDrainIntegration[]
}

model ElasticLogDrainIntegration {
  id               String            @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled          Boolean           @default(true)
  subscription     Subscription?     @relation(fields: [subscriptionId], references: [id])
  subscriptionId   String?           @unique
  tenant           Tenant            @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId         String
  logDrainApp      VercelLogDrainApp @relation(fields: [logDrainAppId], references: [id])
  logDrainAppId    String            @unique
  elasticCluster   ElasticCluster    @relation(fields: [elasticClusterId], references: [id])
  elasticClusterId String            @unique

}

// The ECI Internal Package model
model Package {
  // internal id
  id                 String         @id
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  carrier            Carrier
  state              PackageState
  // tracking id from the carrier
  trackingId         String         @unique
  // A link to the carriers tracking page
  carrierTrackingUrl String?
  order              Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId            String
  events             PackageEvent[]
}

model PackageEvent {
  id        String              @id
  // When the event happened
  time      DateTime
  state     PackageState
  // What happened
  // eg: "The shipment has cleared customs"
  message   String?
  package   Package             @relation(fields: [packageId], references: [id], onDelete: Cascade)
  packageId String
  // `NÃ¼rnberg, Deutschland` for example
  location  String?
  sentEmail TransactionalEmail?
}

model TransactionalEmail {
  id             String       @id
  time           DateTime
  email          String
  // Sendgrid returns a unique id for each email
  sentEmailId    String
  // The related package event that caused this email to be sent
  packageEvent   PackageEvent @relation(fields: [packageEventId], references: [id])
  packageEventId String       @unique
}

model TrackingEmailApp {
  id                String                @id
  tenant            Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId          String
  sendgridTemplates SendgridTemplate[]
  defaultLanguage   Language
  sender            String
  replyTo           String
  integration       TrackingIntegration[]
}

enum Language {
  DE
  EN
}

model SendgridTemplate {
  // internal id
  id                 String           @id
  // A human readable name provided by the user
  // To use internationalized emails you should prefix the name with the language code
  name               String
  packageState       PackageState?
  language           Language
  // Localized subject for the email
  subject            String
  // The template id in sendgrid
  templateId         String
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id], onDelete: Cascade)
  trackingEmailAppId String

  @@unique([trackingEmailAppId, language, packageState])
}

model DpdApp {
  id          String               @id
  name        String?
  tenant      Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId    String               @unique
  integration TrackingIntegration?
  webhooks    IncomingWebhook[]
}

model ProductDataFeedApp {
  id String @id

  // Graphql endpoint of a saleor app
  productDetailStorefrontURL String

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration ProductDataFeedIntegration?
}

model LogisticsApp {
  id String @id

  // The custom view ID use to get all current orders
  currentOrdersCustomViewId String

  // Regular orders in the next fice days custom view
  nextFiveDaysOrdersCustomViewId String

  // The custom view ID to get all current bulk orders
  currentBulkOrdersCustomViewId String

  // custom view ID to get all bulk orders for the next days
  nextFiveDaysBulkOrdersCustomViewId String


  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String @unique

  webhooks    IncomingWebhook[]
  integration LogisticsIntegration?
}

model ZohoApp {
  id String @id

  orgId                    String
  clientId                 String
  clientSecret             String
  tenant                   Tenant                    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId                 String                    @unique
  strapiToZohoIntegrations StrapiToZohoIntegration[]
  logisticsIntegrations    LogisticsIntegration[]
  trackingIntegrations     TrackingIntegration[]

  webhooks              IncomingWebhook[]
  saleorZohoIntegration SaleorZohoIntegration[]
  zohoPayment           ZohoPayment[]
  zohoItem              ZohoItem[]
  zohoWarehouse         ZohoWarehouse[]
  zohoContact           ZohoContact[]
  zohoInvoice           ZohoInvoice[]
  ZohoSalesOrder        ZohoSalesOrder[]
}

// Saleor Apps are separate applications that use GraphQL to talk to a Saleor
// server and receive webhooks with event notifications from Saleor.
// Every tenant can have multiple saleor apps which correspond to different
// saleor instances. Per saleor instance and channel we have just one SaleorApp (we use the shop domain as identification)
model SaleorApp {

  id String @id


  // The domain of a running saleor instance.
  // You can prefix with http:// or https:// if you want.
  // If no protocol is specified, https:// is assumed.
  domain String

  name String

  installedSaleorApp InstalledSaleorApp?

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  @@unique([domain, tenantId])
}

// All ECI Integrations for Saleor should be handled as individual Apps that could be installed via the Marketplace for example
// And the different AppTypes have different settings / webhooks / permissions
enum SaleorAppType {
  productdatafeed
  zohointegration
  mailchimpintegration
  paymentgatewaybanktransfer
  paymentgatewaybraintree
}

// We can have different Installed Saleor Apps for the same Saleor instance. We also have one Installed Saleor App per Channel
model InstalledSaleorApp {
  // The saleor application id
  // This is the id for the app on saleor's side and can be used in queries and
  // mutations to identify the app.
  id String @id

  // should be made mandatory later.
  type SaleorAppType?

  // Every SaleorApp can have multiple webhooks configured.
  // One webhook can fire on multiple events. But for sync webhooks, we need a different one
  webhooks IncomingWebhook[]

  // Unlike regular users, Saleor Apps use a bearer token. The token is
  // assigned at App installation time and needs to be stored in a secure manner.
  // The authorization header for Apps has the following format:
  // Authorization: Bearer <app-token>
  token String

  channelSlug String?


  saleorApp   SaleorApp @relation(fields: [saleorAppId, domain], references: [id, domain], onDelete: Cascade)
  saleorAppId String
  domain      String

  saleorZohoIntegration SaleorZohoIntegration[]

  productDataFeedIntegration ProductDataFeedIntegration[]
  saleorPayment              SaleorPayment[]
  saleorProductVariant       SaleorProductVariant[]
  saleorWarehouse            SaleorWarehouse[]
  saleorOrder                SaleorOrder[]


  @@unique([domain, channelSlug])
}

// One tenant per company
// Every tenant can have multiple connections with every integration.
model Tenant {
  id String @id

  // Human readable identifier
  name String

  subscriptions Subscription[]

  // App configurations
  saleorApps                  SaleorApp[]
  zohoApps                    ZohoApp[]
  productdatafeedApps         ProductDataFeedApp[]
  strapiApps                  StrapiApp[]
  productDataFeedIntegrations ProductDataFeedIntegration[]
  strapiToZohoIntegrations    StrapiToZohoIntegration[]
  logisticsIntegrations       LogisticsIntegration[]
  logisticsApps               LogisticsApp[]
  trackingEmailApps           TrackingEmailApp[]
  dpdApps                     DpdApp[]
  trackingIntegrations        TrackingIntegration[]
  elasticLogDrainIntegration  ElasticLogDrainIntegration[]
  order                       Order[]
  contact                     Contact[]
  company                     Company[]
  saleorZohoIntegration       SaleorZohoIntegration[]
  product                     Product[]
  productVariant              ProductVariant[]
  payment                     Payment[]
  warehouse                   Warehouse[]
  invoice                     Invoice[]
}

// A subscription indicates a tenant has payed for one integration.
model Subscription {
  id String @id

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  payedUntil DateTime?

  productDataFeedIntegration ProductDataFeedIntegration?
  strapiToZohoIntegration    StrapiToZohoIntegration?
  logisticsIntegration       LogisticsIntegration?
  trackingIntegration        TrackingIntegration?
  elasticLogDrainIntegration ElasticLogDrainIntegration[]
  saleorZohoIntegration      SaleorZohoIntegration[]
}

// ----------------------------------------------------------------------------
// Integrations
//
// Every integration is a connection between application configurations and a tenant
// ----------------------------------------------------------------------------

model TrackingIntegration {
  id                 String           @id
  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled            Boolean          @default(true)
  subscription       Subscription?    @relation(fields: [subscriptionId], references: [id])
  subscriptionId     String?          @unique
  tenant             Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId           String
  dpdApp             DpdApp           @relation(fields: [dpdAppId], references: [id])
  dpdAppId           String           @unique
  trackingEmailApp   TrackingEmailApp @relation(fields: [trackingEmailAppId], references: [id])
  trackingEmailAppId String
  zohoApp            ZohoApp?         @relation(fields: [zohoAppId], references: [id])
  zohoAppId          String?
}

model ProductDataFeedIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  productDataFeedApp   ProductDataFeedApp @relation(fields: [productDataFeedAppId], references: [id])
  productDataFeedAppId String             @unique

  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id])
  installedSaleorAppId String?
}

enum CronJobStatus {
  success
  failure
}

// CronJobs / Sync Job model to store the state of synchronisation
// Use the "cronstate" handler to access data in this model
model CronJobState {

  // Generated in this schema: TENANTID_APPID_ENTITY -> Entity is contacts / items / ...
  //                                      ^-- For example the ZohoAppId or the installedSaleorAppId
  id            String         @id
  lastRun       DateTime?
  lastRunStatus CronJobStatus?


}

// The saleor zoho integration consists of several, individual sync jobs
// The code is located in the "integration-entity-sync-saleor" and "integration-entity-sync-zoho"
// - from both sides to the internal ECI database and from the ECI database to the other system
// a customer can make settings here.
model SaleorZohoIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  installedSaleorApp   InstalledSaleorApp @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String

  // The order prefix we use in Zoho to identify orders coming from Saleor
  orderPrefix String @default("STORE")

  // We can create the needed bull jobs for every sync entity, that is enabled
  syncContacts      Boolean @default(false)
  syncWarehouses    Boolean @default(false)
  syncOrders        Boolean @default(false)
  syncInvoices      Boolean @default(false)
  syncPayments      Boolean @default(false)
  syncProductStocks Boolean @default(false)

  // How frequent the synchronisation should run. Default once per hour.
  cronScheduleZoho   String @default("0/15 * * * *")
  cronScheduleSaleor String @default("0/15 * * * *")
  // Time in seconds how long one workflow can run before a timeout occurs.
  cronTimeoutZoho    Int    @default(600)
  cronTimeoutSaleor  Int    @default(600)
}

model LogisticsIntegration {
  id String @id

  // Allow the user to manually enabled or disable the integration
  // Regardless of current subscription state.
  enabled Boolean @default(true)

  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String

  zohoApp   ZohoApp @relation(fields: [zohoAppId], references: [id])
  zohoAppId String

  logisticsApp   LogisticsApp @relation(fields: [logisticsAppId], references: [id])
  logisticsAppId String       @unique
}

model StrapiToZohoIntegration {
  id         String    @id
  payedUntil DateTime?
  enabled    Boolean   @default(true)

  // The Content type of BulkOrders
  strapiContentType String @default("bulkorder")



  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String?       @unique

  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId    String
  strapiApp   StrapiApp @relation(fields: [strapiAppId], references: [id])
  strapiAppId String    @unique
  zohoApp     ZohoApp   @relation(fields: [zohoAppId], references: [id])
  zohoAppId   String

}

// Every tenant can have multiple strapi instances
model StrapiApp {
  id String @id

  name     String
  webhooks IncomingWebhook[]

  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  tenantId String


  integration StrapiToZohoIntegration?
}

// ----------------------------------------------------------------------------
// Every Config/App can have multiple webhooks attached
// ----------------------------------------------------------------------------

model IncomingWebhook {
  id        String     @id
  // Human readable name
  name      String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  secret    SecretKey?


  // Webhook Connections
  dpdApp               DpdApp?             @relation(fields: [dpdAppId], references: [id], onDelete: Cascade)
  dpdAppId             String?
  logisticsApp         LogisticsApp?       @relation(fields: [logisticsAppId], references: [id], onDelete: Cascade)
  logisticsAppId       String?
  productDataFeedApp   ProductDataFeedApp? @relation(fields: [productDataFeedAppId], references: [id], onDelete: Cascade)
  productDataFeedAppId String?
  zohoApp              ZohoApp?            @relation(fields: [zohoAppId], references: [id], onDelete: Cascade)
  zohoAppId            String?
  strapiApp            StrapiApp?          @relation(fields: [strapiAppId], references: [id], onDelete: Cascade)
  strapiAppId          String?
  installedSaleorApp   InstalledSaleorApp? @relation(fields: [installedSaleorAppId], references: [id], onDelete: Cascade)
  installedSaleorAppId String?
  vercelLogDrainApp    VercelLogDrainApp?  @relation(fields: [vercelLogDrainAppId], references: [id], onDelete: Cascade)
  vercelLogDrainAppId  String?

}

model SecretKey {
  id String @id

  // Human readable name
  name      String?
  secret    String
  createdAt DateTime @default(now())


  incomingWebhook   IncomingWebhook @relation(fields: [incomingWebhookId], references: [id], onDelete: Cascade)
  incomingWebhookId String          @unique
}
